<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>弹塑性力学</title>
      <link href="/2024/OldBlogs/08%E5%BC%B9%E5%A1%91%E6%80%A7%E5%8A%9B%E5%AD%A6/"/>
      <url>/2024/OldBlogs/08%E5%BC%B9%E5%A1%91%E6%80%A7%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>内容主要以《工程弹塑性引论》和《弹性力学基础》两本书为主。</p><h1 id="张量分析"><a href="#张量分析" class="headerlink" title="张量分析"></a>张量分析</h1><h2 id="张量基础"><a href="#张量基础" class="headerlink" title="张量基础"></a>张量基础</h2><p>本想详细写一下张量分析基础的，奈何总是拖延，空不出时间来(敲公式太累，bushi），这里先放几个比较好理解的链接吧。<br>需要有一定的线性代数基础，否则这还是看不懂的。该痛苦的还是得痛苦，只不过希望你看完下面链接能有一种轻舟已过万重山的感觉。</p><ol><li><a href="https://www.cnblogs.com/duoba/p/15273401.html">直观认识张量</a></li><li><a href="https://zhuanlan.zhihu.com/p/547791133">张量基本运算</a></li><li><a href="https://wuli.wiki/online/Tensor.html">张量与线性映射</a></li><li><a href="https://dothinking.github.io/2013-07-30-%E5%BA%94%E5%8A%9B%E5%BC%A0%E9%87%8F%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/">应力张量-线性映射</a></li></ol><p>总结来说，张量是一个不变量，在不同基下有不同坐标表达，于是衍生出利用坐标变换定义的张量的形式(1)和坐标分量加基矢量定义法(2)。<br>$$ \tag{1} {T_{{i_1}{i_2}...{i_n}}} = {\beta _{{i_1}{j_1}}}{\beta _{{i_2}{j_2}}}...{\beta _{{i_n}{j_n}}}{T_{{j_1}{j_2}...{j_n}}}$$</p><blockquote><p>$i_1$取1、2、3，其余指标同理； $ {T_{ {i_1} {i_2}…{i_n} } } $是张量$\mathbf{T}$的一个分量，一共$3^n$个这样的分量的有序集合构成一个n阶张量$\mathbf{T}$。</p></blockquote>$$ \tag{2} \mathbf{T} = {T_{{i_1}{i_2}...{i_n}}}{e_{{i_1}}} \otimes {e_{{i_2}}} \otimes ... \otimes {e_{{i_n}}}$$<blockquote><p>最简单的，例如一阶张量，即向量，其定义方式为$ \mathbf{T} = {T_i}{e_i}$，这样对比理解就好了。注意，此处$e_i$都是一阶张量(向量).</p></blockquote><p>当然，很多人直接站在高维角度说，<strong>张量本质是线性映射</strong>。这句话是站在张量应用角度来说的，举几个简单例子，也可仔细阅读链接3、4。</p><ol><li>质量：零阶张量，可以将加速度向量映射成力向量。(此处为线性变换，之所以称线性映射是为了更加普遍的情况)</li><li>应力张量：二阶张量，可以将截面位置映射为截面应力。(详见链接4:<a href="https://dothinking.github.io/2013-07-30-%E5%BA%94%E5%8A%9B%E5%BC%A0%E9%87%8F%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/">应力张量-线性映射</a>)</li></ol><h2 id="虚功原理证明——张量形式"><a href="#虚功原理证明——张量形式" class="headerlink" title="虚功原理证明——张量形式"></a>虚功原理证明——张量形式</h2><p>学了张量分析，总得用一用它吧，看它在证明虚功原理上有多方便！<br><div class="row">    <embed src="virtualwork.pdf" width="100%" height="550" type="application/pdf"></div></p><p>csdn上一篇文章也写得不错，可以参考一下：<a href="https://blog.csdn.net/leizhengshenglzs/article/details/140280675">力学有限元的基石：虚功原理的推导</a></p><h1 id="弹塑性力学数值求解基本过程"><a href="#弹塑性力学数值求解基本过程" class="headerlink" title="弹塑性力学数值求解基本过程"></a>弹塑性力学数值求解基本过程</h1><p>弹塑性材料的数值求解目标是：<strong>已知总应变增量，求下一步的应力状态</strong>。其核心是“材料状态更新”（stress update），在有限元中由返回映射（return-mapping）算法实现。全过程可分为以下关键步骤：</p><p><strong>（1）弹性试算（Predictor Step）</strong><br>根据弹性本构关系，先假设本步完全弹性：</p>$$\tag{1} \sigma_{trial}=\sigma^{old}+ C: \Delta \varepsilon$$<p>此时不考虑塑性，应力为 trial 状态。</p><p><strong>（2）屈服判定（using Yield Criterion）</strong><br>将试应力代入屈服函数：</p>$$\tag{2}f(\sigma_{trial},\kappa^{old}) \begin{cases}<0 & \text{保持弹性，无塑性}\\>0 & \text{发生塑性，需要修正}\end{cases}$$<p>屈服准则决定是否需要进入塑性返回映射。</p><p><strong>（3）塑性修正（Corrector Step：流动法则 + 强化法则）</strong><br>若试应力越过屈服面，需要沿塑性流动方向将其“投回”到屈服面上：</p><ul><li><strong>流动法则（Flow Rule）</strong>决定塑性应变增量方向：</li></ul>$$\tag{3}d\varepsilon^p = d\lambda \frac{\partial g}{\partial \sigma}$$<p>其中 $g$ 为塑性势函数；若 $g=f$，为关联流动法则。</p><ul><li><strong>强化准则（Hardening Rule）</strong>控制屈服面随塑性发展如何变化：  <ul><li>各向同性强化：屈服球（或屈服面）变大  </li><li>运动强化：屈服面平移  </li><li>混合强化：两者叠加  </li></ul></li></ul><p>强化变量 $\kappa$ 通常满足  </p>$$\tag{4}d\kappa = h(d\lambda)$$<p>塑性修正通过求解一致方程：</p>$$\tag{5}f(\sigma^{new},\kappa^{new})=0$$<p>得到塑性乘子 $\Delta \lambda$，并更新应力与内变量。</p><p><strong>（4）更新本构切线与状态量</strong><br>用于有限元求解的切线刚度需保证收敛性：</p>$$\tag{6}\mathbb{C}_{ep} = \frac{\partial \sigma}{\partial \varepsilon}$$<p>最后存储更新后的：  </p><ul><li>应力  </li><li>塑性应变  </li><li>强化变量  </li><li>切线刚度  </li></ul><p>这就是弹塑性数值求解完整流程。</p><h1 id="H-W空间直角坐标系与柱坐标系关系"><a href="#H-W空间直角坐标系与柱坐标系关系" class="headerlink" title="H-W空间直角坐标系与柱坐标系关系"></a>H-W空间直角坐标系与柱坐标系关系</h1><p>三维主应力空间 $(\sigma_1,\sigma_2,\sigma_3)$ 常通过 Haigh–Westergaard（H-W）变换转化为更具有材料物理意义的坐标系。</p><p><strong>（1）直角坐标系：主应力空间</strong></p>$$\tag{7}(\sigma_1,\sigma_2,\sigma_3)$$<p>坐标轴是三个主应力，几何上难直观看材料行为。</p><hr><p><strong>（2）H-W 正交坐标（ξ, ρ, z）</strong></p><p>通过正交变换，将主应力分解成：  </p><ul><li><strong>ξ</strong>：体积方向  </li><li><strong>ρ</strong>：偏应力大小  </li><li><strong>z</strong>：Lode 角方向的偏应力分量  </li></ul><p>通常写作：</p>$$\tag{8}\xi = \frac{1}{\sqrt{3}}(\sigma_1+\sigma_2+\sigma_3)=\frac{I_1}{\sqrt{3}}$$$$\tag{9}\rho=\sqrt{\frac{2}{3}}\,\sqrt{J_2}$$<hr><p><strong>（3）柱坐标形式：$I_1, \sqrt{J_2}, \theta$</strong>  </p><p>这是屈服面最常使用的形式：</p><ul><li>$I_1$：体积应力 → 决定材料受压/受拉状态  </li><li>$\sqrt{J_2}$：剪切强度大小  </li><li>$\theta$：Lode 角（剪切模式）</li></ul><p>其中：</p>$$\tag{10}\sin 3\theta = \frac{3\sqrt{3}}{2}\frac{J_3}{J_2^{3/2}}$$<p>因此：  </p><ul><li>主应力空间 = “几何坐标”  </li><li>$I_1, J_2, \theta$ = “物理意义坐标”  </li></ul><p>通过此映射，屈服面形状和材料特性可以被极为清晰地表达。</p><h1 id="不同屈服准则适用条件及各参数作用"><a href="#不同屈服准则适用条件及各参数作用" class="headerlink" title="不同屈服准则适用条件及各参数作用"></a>不同屈服准则适用条件及各参数作用</h1><hr><p><strong>（1）von Mises 屈服准则（适用于金属）</strong></p>$$\tag{11}f=\sqrt{J_2}-k=0$$<p>特点：  </p><ul><li>不依赖 $I_1$、$\theta$  </li><li>适合延性金属  </li></ul><p>参数含义：  </p><ul><li>$k$：屈服剪切强度  </li></ul><hr><p><strong>（2）Tresca 屈服准则（适用于金属）</strong></p>$$\tag{12}f=\max|\sigma_i-\sigma_j|- \sigma_Y=0$$<p>特点：  </p><ul><li>明显依赖 Lode 角（六角形屈服面）  </li><li>更精确但不光滑  </li></ul><p>参数：  </p><ul><li>$\sigma_Y$：屈服强度  </li></ul><hr><p><strong>（3）Drucker–Prager（DP）准则（适用于土、岩石、混凝土）</strong></p>$$\tag{13}f=\alpha I_1 + \sqrt{J_2}-k=0$$<p>特点：  </p><ul><li>考虑 $I_1$（压力敏感）  </li><li><strong>不依赖 $\theta$</strong>  </li></ul><p>参数：  </p><ul><li>$\alpha$：压力敏感度  </li><li>$k$：剪切屈服强度  </li></ul><hr><p><strong>（4）Mohr–Coulomb（MC）准则（适用于岩土材料）</strong></p>$$\tag{14}f= \tau - \sigma \tan\phi - c=0$$<p>转化到三维后依赖：  </p><ul><li>$I_1$  </li><li>$J_2$  </li><li>$\theta$  </li></ul><p>参数：  </p><ul><li>$c$：黏聚力  </li><li>$\phi$：内摩擦角  </li></ul><hr><p><strong>（5）Willam–Warnke / Matsuoka–Nakai（混凝土高精度模型）</strong><br>特点：  </p><ul><li>强烈依赖 $\theta$  </li><li>屈服面呈三角形或花瓣状  </li></ul><hr><p><strong>（6）Cam-Clay（黏性土）</strong></p>$$\tag{15}f = \frac{3}{2}\frac{s:s}{(M p)^2} + \frac{p(p-p_c)}{p_c^2}=0$$<p>特点：  </p><ul><li>强 $I_1$ 依赖  </li><li>描述固结、体积–剪切耦合  </li></ul><p>参数：  </p><ul><li>$M$：剪胀参数  </li><li>$p_c$：前期固结压力  </li></ul><hr><p><strong>总体总结：</strong></p><ul><li>$I_1$：体积应力，决定压力敏感性  </li><li>$J_2$：剪切强度大小  </li><li>$\theta$：剪切模式（拉剪/压剪/纯剪）  </li></ul><p>屈服准则的差别主要体现在：  </p><ul><li>是否考虑压力敏感性（$I_1$）  </li><li>是否考虑剪切模式（$\theta$）  </li><li>屈服面几何是否光滑、连续、可导</li></ul><h1 id="弹塑性力学大作业"><a href="#弹塑性力学大作业" class="headerlink" title="弹塑性力学大作业"></a>弹塑性力学大作业</h1><p>本次作业的完成离不开吴长厚吴兄的帮忙，在此对他表示感谢。</p><div class="row">    <embed src="弹塑性力学作业.pdf" width="100%" height="550" type="application/pdf"></div></0>]]></content>
      
      
      <categories>
          
          <category> 力学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 弹塑性力学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析算法集锦</title>
      <link href="/2025/02/02%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
      <url>/2025/02/02%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>已经考完啦，感觉还是比较轻松的，所以没写的估计也不会再写啦，就把框架先搭起来吧。</p></blockquote><h1 id="线性代数方程组的直接法"><a href="#线性代数方程组的直接法" class="headerlink" title="线性代数方程组的直接法"></a>线性代数方程组的直接法</h1><p>在matlab中有直接求解的命令<code>x = A\b</code>,matlab会自动根据矩阵A的性质采用相应的算法（高斯消元、LU分解、最小二乘法等）进行求解，这里为了学习（应付考试），还是从基础一步步复现。</p><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> = <span class="title">Gauss</span><span class="params">(A, b)</span></span></span><br><span class="line">    N = <span class="built_in">length</span>(b);</span><br><span class="line">    x = <span class="built_in">zeros</span>(N,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% Forward Elimination</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>:N</span><br><span class="line">            m = A(<span class="built_in">j</span>,<span class="built_in">i</span>) / A(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">            A(<span class="built_in">j</span>,<span class="built_in">i</span>:N) = A(<span class="built_in">j</span>,<span class="built_in">i</span>:N) - m * A(<span class="built_in">i</span>,<span class="built_in">i</span>:N);</span><br><span class="line">            b(<span class="built_in">j</span>) = b(<span class="built_in">j</span>) - m * b(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Back Substitution</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = N:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">        x(<span class="built_in">i</span>) = (b(<span class="built_in">i</span>) - A(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:N) * x(<span class="built_in">i</span>+<span class="number">1</span>:N)) / A(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Crout分解"><a href="#Crout分解" class="headerlink" title="Crout分解"></a>Crout分解</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x]</span> = <span class="title">Crout</span><span class="params">(A,b)</span></span></span><br><span class="line">    n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line">    x = <span class="built_in">zeros</span>(n,<span class="number">1</span>);</span><br><span class="line">    L = <span class="built_in">zeros</span>(n);</span><br><span class="line">    U = <span class="built_in">eye</span>(n);  <span class="comment">% U 对角线为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="built_in">j</span>:n</span><br><span class="line">            L(<span class="built_in">i</span>,<span class="built_in">j</span>) = A(<span class="built_in">i</span>,<span class="built_in">j</span>) - L(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)*U(<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="built_in">j</span>+<span class="number">1</span>:n</span><br><span class="line">            U(<span class="built_in">j</span>,<span class="built_in">i</span>) = (A(<span class="built_in">j</span>,<span class="built_in">i</span>) - L(<span class="built_in">j</span>,<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)*U(<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">i</span>)) / L(<span class="built_in">j</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    y = <span class="built_in">zeros</span>(n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">        y(<span class="built_in">i</span>) = (b(<span class="built_in">i</span>) - L(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*y(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>))./L(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = n:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">        x(<span class="built_in">i</span>) = (y(<span class="built_in">i</span>) - U(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:n)*x(<span class="built_in">i</span>+<span class="number">1</span>:n));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Doolittle分解"><a href="#Doolittle分解" class="headerlink" title="Doolittle分解"></a>Doolittle分解</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x]</span> = <span class="title">Doolittle</span><span class="params">(A,b)</span></span></span><br><span class="line">    N = <span class="built_in">length</span>(b);</span><br><span class="line">    L = <span class="built_in">eye</span>(N);</span><br><span class="line">    U = <span class="built_in">zeros</span>(N);</span><br><span class="line">    x = <span class="built_in">zeros</span>(N,<span class="number">1</span>);y = <span class="built_in">zeros</span>(N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>:N</span><br><span class="line">            U(<span class="built_in">i</span>,<span class="built_in">j</span>) = A(<span class="built_in">i</span>,<span class="built_in">j</span>) - L(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*U(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>:N</span><br><span class="line">            L(<span class="built_in">j</span>,<span class="built_in">i</span>) = (A(<span class="built_in">j</span>,<span class="built_in">i</span>) - L(<span class="built_in">j</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*U(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">i</span>) )./U(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        y(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) - L(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*y(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = N:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">        x(<span class="built_in">i</span>) = (y(<span class="built_in">i</span>) - U(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:N)*y(<span class="built_in">i</span>+<span class="number">1</span>:N))./U(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Cholesky分解"><a href="#Cholesky分解" class="headerlink" title="Cholesky分解"></a>Cholesky分解</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x]</span> = <span class="title">Cholesky</span><span class="params">(A,b)</span></span></span><br><span class="line">    N = <span class="built_in">length</span>(b);</span><br><span class="line">    G = <span class="built_in">zeros</span>(N);</span><br><span class="line">    x = <span class="built_in">zeros</span>(N,<span class="number">1</span>);y = <span class="built_in">zeros</span>(N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        G(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(A(<span class="built_in">i</span>,<span class="built_in">i</span>) - G(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*G(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)&#x27;);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>:N</span><br><span class="line">            G(<span class="built_in">j</span>,<span class="built_in">i</span>) = (A(<span class="built_in">j</span>,<span class="built_in">i</span>) - G(<span class="built_in">j</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*G(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)&#x27;)./G(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    GT = G&#x27;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        y(<span class="built_in">i</span>) = (b(<span class="built_in">i</span>) - G(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*y(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>))./G(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = N:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">        x(<span class="built_in">i</span>) = (y(<span class="built_in">i</span>) - GT(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:N)*y(<span class="built_in">i</span>+<span class="number">1</span>:N))./GT(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>评述：</p><blockquote><p>无论是Crout、Doolittle还是Cholesky分解，都是从第i列开始，分别求L的剩余列（i:N,i）,U的剩余行（i,i:N）,先算L还是先算U，取决于哪个矩阵对角线不是1。Cholesky分解中L=U=G，但是注意，Cholesky分解只适用于对称正定矩阵。</p></blockquote><h2 id="追赶法"><a href="#追赶法" class="headerlink" title="追赶法"></a>追赶法</h2><p>下面是采用Crout分解的追赶法。其实追赶法就是边分解边求解，降低了运算复杂度。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x]</span> = <span class="title">ZhuiGan</span><span class="params">(A,b)</span></span></span><br><span class="line">    N = <span class="built_in">length</span>(b);</span><br><span class="line">    L = <span class="built_in">zeros</span>(N);</span><br><span class="line">    U = <span class="built_in">eye</span>(N);</span><br><span class="line">    y = <span class="built_in">zeros</span>(N,<span class="number">1</span>); x = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 追的过程</span></span><br><span class="line">    L(<span class="number">1</span>,<span class="number">1</span>) = A(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    L(<span class="number">2</span>,<span class="number">1</span>) = A(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    U(<span class="number">1</span>,<span class="number">2</span>) = A(<span class="number">1</span>,<span class="number">2</span>)./L(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    y(<span class="number">1</span>) = b(<span class="number">1</span>)./L(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:N<span class="number">-1</span></span><br><span class="line">        L(<span class="built_in">i</span>,<span class="built_in">i</span>) = A(<span class="built_in">i</span>,<span class="built_in">i</span>)- U(<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">i</span>).*L(<span class="built_in">i</span>,<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">        L(<span class="built_in">i</span>+<span class="number">1</span>,<span class="built_in">i</span>) = A(<span class="built_in">i</span>+<span class="number">1</span>,<span class="built_in">i</span>);</span><br><span class="line">        U(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>) = A(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>)./L(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        y(<span class="built_in">i</span>) = (b(<span class="built_in">i</span>) - L(<span class="built_in">i</span>,<span class="built_in">i</span><span class="number">-1</span>).*y(<span class="built_in">i</span><span class="number">-1</span>))./L(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    L(N,N) = A(N,N) - L(N,N<span class="number">-1</span>).*U(N<span class="number">-1</span>,N);</span><br><span class="line">    y(N) = (b(N) - L(N,N<span class="number">-1</span>).*y(N<span class="number">-1</span>))./L(N,N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 赶的过程</span></span><br><span class="line">    x(N) = y(N);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = N<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">        x(<span class="built_in">i</span>) = y(<span class="built_in">i</span>) - U(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>).*x(<span class="built_in">i</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h1 id="线性方程组的迭代解法"><a href="#线性方程组的迭代解法" class="headerlink" title="线性方程组的迭代解法"></a>线性方程组的迭代解法</h1><h2 id="Jacobi迭代"><a href="#Jacobi迭代" class="headerlink" title="Jacobi迭代"></a>Jacobi迭代</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> = <span class="title">Jacobi</span><span class="params">(A,b,x0,tol)</span></span></span><br><span class="line">    D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));</span><br><span class="line">    L = -<span class="built_in">tril</span>(A,<span class="number">-1</span>);</span><br><span class="line">    U = -<span class="built_in">triu</span>(A,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    x1 = D \ ((L+U)*x0+b);</span><br><span class="line">    <span class="keyword">while</span> norm(x1-x0,<span class="number">2</span>) &gt; tol</span><br><span class="line">        x0 = x1;</span><br><span class="line">        x1 = D \ ((L+U)*x0+b);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x = x1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="线性方程组的迭代法"><a href="#线性方程组的迭代法" class="headerlink" title="线性方程组的迭代法"></a>线性方程组的迭代法</h1><h2 id="Jacobi迭代-1"><a href="#Jacobi迭代-1" class="headerlink" title="Jacobi迭代"></a>Jacobi迭代</h2><h2 id="GS迭代"><a href="#GS迭代" class="headerlink" title="GS迭代"></a>GS迭代</h2><h2 id="SOR迭代"><a href="#SOR迭代" class="headerlink" title="SOR迭代"></a>SOR迭代</h2><h1 id="多项式插值与样条插值"><a href="#多项式插值与样条插值" class="headerlink" title="多项式插值与样条插值"></a>多项式插值与样条插值</h1><h2 id="Lagrange插值"><a href="#Lagrange插值" class="headerlink" title="Lagrange插值"></a>Lagrange插值</h2><h2 id="Newton插值"><a href="#Newton插值" class="headerlink" title="Newton插值"></a>Newton插值</h2><h2 id="Hermite插值"><a href="#Hermite插值" class="headerlink" title="Hermite插值"></a>Hermite插值</h2><h2 id="三次样条插值"><a href="#三次样条插值" class="headerlink" title="三次样条插值"></a>三次样条插值</h2><h1 id="函数逼近"><a href="#函数逼近" class="headerlink" title="函数逼近"></a>函数逼近</h1><h2 id="线性最佳一致逼近"><a href="#线性最佳一致逼近" class="headerlink" title="线性最佳一致逼近"></a>线性最佳一致逼近</h2><h2 id="线性最佳平方逼近（最小二乘法）"><a href="#线性最佳平方逼近（最小二乘法）" class="headerlink" title="线性最佳平方逼近（最小二乘法）"></a>线性最佳平方逼近（最小二乘法）</h2><h1 id="数值积分和数值积分"><a href="#数值积分和数值积分" class="headerlink" title="数值积分和数值积分"></a>数值积分和数值积分</h1><h2 id="中点公式"><a href="#中点公式" class="headerlink" title="中点公式"></a>中点公式</h2><h2 id="梯形公式"><a href="#梯形公式" class="headerlink" title="梯形公式"></a>梯形公式</h2><h2 id="Simpson公式"><a href="#Simpson公式" class="headerlink" title="Simpson公式"></a>Simpson公式</h2><h2 id="Newton-cotes公式"><a href="#Newton-cotes公式" class="headerlink" title="Newton-cotes公式"></a>Newton-cotes公式</h2><h2 id="Ramberg积分"><a href="#Ramberg积分" class="headerlink" title="Ramberg积分"></a>Ramberg积分</h2><h2 id="高斯积分"><a href="#高斯积分" class="headerlink" title="高斯积分"></a>高斯积分</h2><h1 id="非线性方程组的数值解法"><a href="#非线性方程组的数值解法" class="headerlink" title="非线性方程组的数值解法"></a>非线性方程组的数值解法</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h2 id="不动点迭代法"><a href="#不动点迭代法" class="headerlink" title="不动点迭代法"></a>不动点迭代法</h2><h2 id="牛顿（Newton-Raphson）法"><a href="#牛顿（Newton-Raphson）法" class="headerlink" title="牛顿（Newton-Raphson）法"></a>牛顿（Newton-Raphson）法</h2><h2 id="割线法"><a href="#割线法" class="headerlink" title="割线法"></a>割线法</h2><h1 id="常微分方程初边值问题数值解"><a href="#常微分方程初边值问题数值解" class="headerlink" title="常微分方程初边值问题数值解"></a>常微分方程初边值问题数值解</h1><h2 id="欧拉折线法"><a href="#欧拉折线法" class="headerlink" title="欧拉折线法"></a>欧拉折线法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span> = <span class="title">Euler</span><span class="params">(a,b,h,y0,f)</span></span></span><br><span class="line">    x = a:h:b;</span><br><span class="line">    y(<span class="number">1</span>) = y0;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">size</span>(x,<span class="number">2</span>)</span><br><span class="line">        y(<span class="built_in">i</span>) = y(<span class="built_in">i</span><span class="number">-1</span>)- h*f(x(<span class="built_in">i</span><span class="number">-1</span>),y(<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="欧拉梯形法"><a href="#欧拉梯形法" class="headerlink" title="欧拉梯形法"></a>欧拉梯形法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span> = <span class="title">trapze_euler</span><span class="params">(a,b,h,y0,f,g,max_iter,error)</span></span></span><br><span class="line">    <span class="comment">% g  : df/dy</span></span><br><span class="line">    x = a:h:b;</span><br><span class="line">    N = <span class="built_in">length</span>(x);</span><br><span class="line">    y = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">    y(<span class="number">1</span>) = y0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:N</span><br><span class="line">        y_guess = y(<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:max_iter</span><br><span class="line">            G = y_guess - y(<span class="built_in">i</span><span class="number">-1</span>) - <span class="number">0.5</span>*h*(f(x(<span class="built_in">i</span><span class="number">-1</span>),y(<span class="built_in">i</span><span class="number">-1</span>))+f(x(<span class="built_in">i</span>),y_guess));</span><br><span class="line">            dG = <span class="number">1</span><span class="number">-0.5</span>*h*(g(x(<span class="built_in">i</span>),y_guess));</span><br><span class="line">            y_guess = y_guess - G./dG;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(G) &lt; error</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        y(<span class="built_in">i</span>) = y_guess;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="改进的欧拉方法"><a href="#改进的欧拉方法" class="headerlink" title="改进的欧拉方法"></a>改进的欧拉方法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span> = <span class="title">Improved_euler</span><span class="params">(a,b,h,y0,f)</span></span></span><br><span class="line">    x = a:h:b;</span><br><span class="line">    N = <span class="built_in">length</span>(x);</span><br><span class="line">    y = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">    y(<span class="number">1</span>) = y0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:N</span><br><span class="line">        yp = y(<span class="built_in">i</span><span class="number">-1</span>) + h*f(x(<span class="built_in">i</span><span class="number">-1</span>),y(<span class="built_in">i</span><span class="number">-1</span>));</span><br><span class="line">        yc = y(<span class="built_in">i</span><span class="number">-1</span>) + <span class="number">0.5</span> *h *(f(x(<span class="built_in">i</span><span class="number">-1</span>),y(<span class="built_in">i</span><span class="number">-1</span>)),f(x(<span class="built_in">i</span>),yp));</span><br><span class="line">        y(<span class="built_in">i</span>) = <span class="number">0.5</span>*(yc+yp);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Runge-kutta方法"><a href="#Runge-kutta方法" class="headerlink" title="Runge-kutta方法"></a>Runge-kutta方法</h2>]]></content>
      
      
      <categories>
          
          <category> 数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学术论文写作时态</title>
      <link href="/2025/05/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E6%97%B6%E6%80%81/"/>
      <url>/2025/05/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E6%97%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="论文各章节常用时态指南（含“提出新结构-算法”的情况）"><a href="#论文各章节常用时态指南（含“提出新结构-算法”的情况）" class="headerlink" title="论文各章节常用时态指南（含“提出新结构/算法”的情况）"></a>论文各章节常用时态指南（含“提出新结构/算法”的情况）</h1><hr><h2 id="1-标题（Title）"><a href="#1-标题（Title）" class="headerlink" title="1. 标题（Title）"></a>1. 标题（Title）</h2><ul><li><strong>时态</strong>：通常省略动词，使用名词短语</li><li>✅ 示例：<blockquote><p>A New Joint Design for Precast Concrete Frames<br>Deep Learning-Based Algorithm for BIM–Reality Registration</p></blockquote></li></ul><hr><h2 id="2-摘要（Abstract）"><a href="#2-摘要（Abstract）" class="headerlink" title="2. 摘要（Abstract）"></a>2. 摘要（Abstract）</h2><ul><li><p><strong>主要时态</strong>：</p><ul><li><strong>一般现在时</strong>（描述本文内容，特别是“本文提出…”）✅<ul><li>“This paper <strong>proposes</strong> a new joint design …”  </li><li>“We <strong>present</strong> a registration algorithm based on …”</li></ul></li><li><strong>一般过去时</strong>（具体实验做法或测试过程）<ul><li>“We <strong>tested</strong> the node under cyclic loading.”  </li></ul></li></ul></li><li>🔍 如果你在摘要中<strong>声明创新点或贡献</strong>：<strong>使用现在时</strong>  </li><li>✅ 示例段落：<blockquote><p>This paper <strong>proposes</strong> a novel steel–concrete joint for precast systems. A full-scale test <strong>was conducted</strong> to verify its seismic performance. Results <strong>show</strong> that the joint significantly improves ductility.</p></blockquote></li></ul><hr><h2 id="3-引言（Introduction）"><a href="#3-引言（Introduction）" class="headerlink" title="3. 引言（Introduction）"></a>3. 引言（Introduction）</h2><ul><li><p><strong>主要时态</strong>：</p><ul><li><strong>一般现在时</strong>：<ul><li>用于说明背景、动机、重要性  </li><li>用于明确论文贡献（即“本文提出…”）✅  </li><li>示例：<ul><li>“BIM–reality alignment <strong>is</strong> vital for construction accuracy.”  </li><li>“In this study, we <strong>propose</strong> a new algorithm …” ✅</li></ul></li></ul></li><li><strong>一般现在时</strong>：评价文献“观点”、“结论”  <ul><li>“Smith (2020) <strong>argues</strong> that …”  </li></ul></li><li><strong>现在完成时</strong>：强调文献发展脉络  <ul><li>“Researchers <strong>have explored</strong> multi‐sensor fusion since 2015.”  </li></ul></li></ul></li><li><p>✅ <strong>论文自己的创新点（提出新结构、算法）→用现在时！</strong></p></li><li><p>✅ 示例句：</p><blockquote><p>In this paper, we <strong>propose</strong> a deep learning–based algorithm for point-cloud to BIM registration. Compared with existing methods, the algorithm <strong>offers</strong> higher precision and lower computational cost.</p></blockquote></li></ul><hr><h2 id="4-材料与方法（Materials-amp-Methods）"><a href="#4-材料与方法（Materials-amp-Methods）" class="headerlink" title="4. 材料与方法（Materials &amp; Methods）"></a>4. 材料与方法（Materials &amp; Methods）</h2><ul><li><strong>主要时态</strong>：<ul><li><strong>一般过去时</strong>：<ul><li>描述实验、建模、测试流程  </li><li>示例：<ul><li>“The node <strong>was cast</strong> using HRB400 steel.”  </li><li>“We <strong>implemented</strong> the algorithm in Python.”</li></ul></li></ul></li><li><strong>一般现在时</strong>：<ul><li>对于算法、流程图、方程的<strong>构造描述本身</strong>，可以用现在时  </li><li>示例：<ul><li>“The model <strong>consists</strong> of three modules.”  </li></ul></li></ul></li></ul></li><li>❗ 新提出的结构或算法逻辑描述（如模块设计）可用<strong>现在时</strong>，但步骤执行仍用<strong>过去时</strong>  </li><li>✅ 示例：<blockquote><p>The proposed algorithm <strong>includes</strong> a feature extraction module, a coarse registration stage, and a refinement process. We <strong>trained</strong> the model using synthetic point clouds.</p></blockquote></li></ul><hr><h2 id="5-结果（Results）"><a href="#5-结果（Results）" class="headerlink" title="5. 结果（Results）"></a>5. 结果（Results）</h2><ul><li><strong>主要时态</strong>：<ul><li><strong>过去时</strong>：<ul><li>实验或仿真数据呈现（例如算法性能、节点承载力）</li><li>“The proposed node <strong>withstood</strong> a drift of 2.5%.”</li></ul></li><li><strong>现在时</strong>：<ul><li>图表、趋势、对比描述  </li><li>“Figure 4 <strong>shows</strong> the displacement pattern.”</li></ul></li></ul></li></ul><hr><h2 id="6-讨论（Discussion）"><a href="#6-讨论（Discussion）" class="headerlink" title="6. 讨论（Discussion）"></a>6. 讨论（Discussion）</h2><ul><li><strong>主要时态</strong>：<ul><li><strong>现在时</strong>：<ul><li>对结果的解释、对比、影响、贡献的讨论</li><li>“These results <strong>indicate</strong> that the joint <strong>enhances</strong> energy dissipation.”  </li><li>“The algorithm <strong>performs</strong> better than traditional ICP.”</li></ul></li><li><strong>过去时</strong>：<ul><li>回顾本文具体观察或实验行为</li><li>“We <strong>observed</strong> early yielding in Specimen B.”</li></ul></li></ul></li></ul><hr><h2 id="7-结论（Conclusion）"><a href="#7-结论（Conclusion）" class="headerlink" title="7. 结论（Conclusion）"></a>7. 结论（Conclusion）</h2><ul><li><strong>主要时态</strong>：<ul><li><strong>现在时</strong>（总结贡献、陈述创新点）✅  <ul><li>“This paper <strong>proposes</strong> a novel joint …”  </li><li>“The algorithm <strong>demonstrates</strong> high accuracy.”  </li></ul></li><li><strong>将来时</strong>（展望未来研究）<ul><li>“Future work <strong>will focus</strong> on field validation.”</li></ul></li></ul></li><li>✅ 如果你在结论中重申“本文提出了某种算法/结构”，请使用<strong>现在时</strong>！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地震动反应谱计算及分析</title>
      <link href="/2025/05/%E5%9C%B0%E9%9C%87%E5%8A%A8%E5%8F%8D%E5%BA%94%E8%B0%B1%E5%88%86%E6%9E%90%E5%8F%8A%E8%AE%A1%E7%AE%97/"/>
      <url>/2025/05/%E5%9C%B0%E9%9C%87%E5%8A%A8%E5%8F%8D%E5%BA%94%E8%B0%B1%E5%88%86%E6%9E%90%E5%8F%8A%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="地震动反应谱的频域计算原理与实现"><a href="#地震动反应谱的频域计算原理与实现" class="headerlink" title="地震动反应谱的频域计算原理与实现"></a>地震动反应谱的频域计算原理与实现</h1><p>在地震工程学中，<strong>地震动反应谱</strong>是描述结构动力响应最重要的工具之一。本文将介绍一种基于<strong>频域方法</strong>的反应谱计算原理，并结合 MATLAB 实现过程，展示如何高效地计算多个阻尼比下的位移、速度与加速度谱。</p><h2 id="一、反应谱基本定义"><a href="#一、反应谱基本定义" class="headerlink" title="一、反应谱基本定义"></a>一、反应谱基本定义</h2><p>对一个线性单自由度振动系统，其响应受地震动激励影响，反应谱定义为该系统在不同自振周期（$T$）和阻尼比（$\xi$）下的最大响应值，具体包括：</p><ul><li><strong>加速度反应谱</strong>（$S_a(T)$）  </li><li><strong>速度反应谱</strong>（$S_v(T)$）  </li><li><strong>位移反应谱</strong>（$S_d(T)$）</li></ul><h2 id="二、频域法的理论基础"><a href="#二、频域法的理论基础" class="headerlink" title="二、频域法的理论基础"></a>二、频域法的理论基础</h2><h3 id="1-系统动力学方程"><a href="#1-系统动力学方程" class="headerlink" title="1. 系统动力学方程"></a>1. 系统动力学方程</h3><p>考虑质量 $m$、阻尼比 $\xi$、固有频率 $\omega_n = \frac{2\pi}{T}$ 的单自由度系统，受到地震动加速度 $\ddot{u}_g(t)$ 激励，其相对位移 $u(t)$ 满足：</p><script type="math/tex; mode=display">\ddot{u}(t) + 2\xi\omega_n\dot{u}(t) + \omega_n^2 u(t) = -\ddot{u}_g(t)</script><h3 id="2-频域响应表达式"><a href="#2-频域响应表达式" class="headerlink" title="2. 频域响应表达式"></a>2. 频域响应表达式</h3><p>将上式进行傅里叶变换，得到系统响应的频域表示：</p><script type="math/tex; mode=display">U(\omega) = H(\omega) \cdot A_g(\omega)</script><p>其中：</p><ul><li>$A_g(\omega)$：地震动加速度的频谱（由 FFT 得到）  </li><li>$H(\omega)$：系统的频率响应函数，表示对单位输入的响应：</li></ul><script type="math/tex; mode=display">H(\omega) = \frac{1}{-\omega^2 + 2i\xi\omega\omega_n + \omega_n^2}</script><h2 id="三、三种响应谱的频域计算方法"><a href="#三、三种响应谱的频域计算方法" class="headerlink" title="三、三种响应谱的频域计算方法"></a>三、三种响应谱的频域计算方法</h2><h3 id="1-位移谱-S-d-T"><a href="#1-位移谱-S-d-T" class="headerlink" title="1. 位移谱 $S_d(T)$"></a>1. 位移谱 $S_d(T)$</h3><script type="math/tex; mode=display">U(\omega) = H(\omega) \cdot A_g(\omega)</script><p>取反傅里叶变换 $u(t) = \mathcal{F}^{-1}[U(\omega)]$，位移谱为其最大绝对值：</p><script type="math/tex; mode=display">S_d(T) = \max |u(t)|</script><h3 id="2-速度谱-S-v-T"><a href="#2-速度谱-S-v-T" class="headerlink" title="2. 速度谱 $S_v(T)$"></a>2. 速度谱 $S_v(T)$</h3><script type="math/tex; mode=display">V(\omega) = i\omega \cdot H(\omega) \cdot A_g(\omega)</script><p>反变换得 $v(t)$，求最大值：</p><script type="math/tex; mode=display">S_v(T) = \max |v(t)|</script><h3 id="3-加速度谱-S-a-T"><a href="#3-加速度谱-S-a-T" class="headerlink" title="3. 加速度谱 $S_a(T)$"></a>3. 加速度谱 $S_a(T)$</h3><p>计算相对加速度：</p><script type="math/tex; mode=display">A_{\text{rel}}(\omega) = -\omega^2 \cdot H(\omega) \cdot A_g(\omega)</script><p>加上原始地震动得绝对加速度：</p><script type="math/tex; mode=display">a_{\text{abs}}(t) = a_{\text{rel}}(t) + \ddot{u}_g(t)</script><p>谱值为其最大值除以重力加速度：</p><script type="math/tex; mode=display">S_a(T) = \frac{\max |a_{\text{abs}}(t)|}{g}</script><h2 id="四、阻尼比与周期的多维计算"><a href="#四、阻尼比与周期的多维计算" class="headerlink" title="四、阻尼比与周期的多维计算"></a>四、阻尼比与周期的多维计算</h2><p>在实际工程中，通常会选取多个阻尼比（例如 0%、1%、2%、5%、10%）以及一定周期范围（如 $T \in [0.01, 10]\, \text{s}$），分别计算对应的谱曲线，形成完整的谱图族。</p><h2 id="五、频域方法的优势"><a href="#五、频域方法的优势" class="headerlink" title="五、频域方法的优势"></a>五、频域方法的优势</h2><p>与时域积分法相比，频域方法具有以下优点：</p><ul><li><strong>效率高</strong>：通过快速傅里叶变换（FFT）加速运算，适用于大量地震波处理；</li><li><strong>直观分析</strong>：频域可揭示系统与激励的滤波关系；</li><li><strong>适应性强</strong>：便于扩展至不同频率带宽和采样率的地震动。</li></ul><h2 id="MATLAB实现"><a href="#MATLAB实现" class="headerlink" title="MATLAB实现"></a>MATLAB实现</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">clear; clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">% -------------------- 参数 --------------------</span></span><br><span class="line">damping_ratios = [<span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.10</span>];  <span class="comment">% 阻尼比</span></span><br><span class="line">T = <span class="built_in">linspace</span>(<span class="number">0.01</span>, <span class="number">10</span>, <span class="number">1000</span>);                 <span class="comment">% 周期范围 (s)</span></span><br><span class="line">dt = <span class="number">0.01</span>;                                     <span class="comment">% 时间步长 (s)</span></span><br><span class="line">g = <span class="number">9.81</span>;                                      <span class="comment">% 重力加速度 (m/s^2)</span></span><br><span class="line"></span><br><span class="line">site_dirs = &#123;<span class="string">&#x27;1类场地&#x27;</span>, <span class="string">&#x27;2类场地&#x27;</span>, <span class="string">&#x27;3类场地&#x27;</span>,<span class="string">&#x27;4类场地&#x27;</span>&#125;;  <span class="comment">% 场地文件夹列表 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 反应谱文件夹名称映射</span></span><br><span class="line">spec_folders = &#123;<span class="string">&#x27;加速度谱&#x27;</span>, <span class="string">&#x27;速度谱&#x27;</span>, <span class="string">&#x27;位移谱&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% 后缀与图例标签</span></span><br><span class="line">suffix = &#123;<span class="string">&#x27;_Sa&#x27;</span>, <span class="string">&#x27;_Sv&#x27;</span>, <span class="string">&#x27;_Sd&#x27;</span>&#125;;</span><br><span class="line">labels = &#123;<span class="string">&#x27;Sa (g)&#x27;</span>, <span class="string">&#x27;Sv (m/s)&#x27;</span>, <span class="string">&#x27;Sd (m)&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% -------------------- 主循环 --------------------</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(site_dirs)</span><br><span class="line">    site_path = site_dirs&#123;<span class="built_in">i</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 在场地文件夹下创建三个子目录</span></span><br><span class="line">    <span class="keyword">for</span> pf = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">        dir_path = fullfile(site_path, spec_folders&#123;pf&#125;);</span><br><span class="line">        <span class="keyword">if</span> ~exist(dir_path, <span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">            mkdir(dir_path);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    files = dir(fullfile(site_path, <span class="string">&#x27;*.txt&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(files)</span><br><span class="line">        <span class="comment">% —— 读取并缩放加速度时程 —— </span></span><br><span class="line">        file_path = fullfile(site_path, files(<span class="built_in">j</span>).name);</span><br><span class="line">        raw_g = load(file_path);</span><br><span class="line">        acc_g = raw_g(:).&#x27;;               <span class="comment">% 单位 g</span></span><br><span class="line">        acc_m = acc_g * g;                <span class="comment">% 转为 m/s^2</span></span><br><span class="line">        scale = (<span class="number">0.1</span> * g) / <span class="built_in">max</span>(<span class="built_in">abs</span>(acc_m));  <span class="comment">% 动态 scale</span></span><br><span class="line">        acc = acc_m * scale;</span><br><span class="line">        n = <span class="built_in">numel</span>(acc);</span><br><span class="line">        </span><br><span class="line">        [~, name, ~] = fileparts(files(<span class="built_in">j</span>).name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% —— 时程图 —— </span></span><br><span class="line">        <span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,[<span class="string">&#x27;TimeHistory - &#x27;</span>, name],<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">        <span class="built_in">plot</span>((<span class="number">0</span>:n<span class="number">-1</span>)*dt, acc, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        grid on; xlabel(<span class="string">&#x27;Time (s)&#x27;</span>); ylabel(<span class="string">&#x27;Acceleration (m/s^2)&#x27;</span>);</span><br><span class="line">        title([<span class="string">&#x27;Acceleration Time History - &#x27;</span>, name]);</span><br><span class="line">        saveas(gcf, fullfile(site_path, [name, <span class="string">&#x27;_TimeHistory.png&#x27;</span>]));</span><br><span class="line">        close;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% —— FFT 频谱 —— </span></span><br><span class="line">        Nfft = <span class="number">2</span>^<span class="built_in">nextpow2</span>(n);</span><br><span class="line">        Acc_f = fft(acc, Nfft);</span><br><span class="line">        freq = (<span class="number">0</span>:Nfft<span class="number">-1</span>)/(Nfft*dt);</span><br><span class="line">        Amp = <span class="built_in">abs</span>(Acc_f)/Nfft;</span><br><span class="line">        Amp(<span class="number">2</span>:<span class="built_in">floor</span>(Nfft/<span class="number">2</span>)) = <span class="number">2</span>*Amp(<span class="number">2</span>:<span class="built_in">floor</span>(Nfft/<span class="number">2</span>));</span><br><span class="line">        f_plot = freq(<span class="number">1</span>:<span class="built_in">floor</span>(Nfft/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">        A_plot = Amp(<span class="number">1</span>:<span class="built_in">floor</span>(Nfft/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,[<span class="string">&#x27;FFT - &#x27;</span>, name],<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">        semilogy(f_plot, A_plot, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        grid on; xlim([<span class="number">0</span>, <span class="number">1</span>/(<span class="number">2</span>*dt)]);</span><br><span class="line">        xlabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>); ylabel(<span class="string">&#x27;Amplitude (m/s^2)&#x27;</span>);</span><br><span class="line">        title([<span class="string">&#x27;Frequency Spectrum - &#x27;</span>, name]);</span><br><span class="line">        saveas(gcf, fullfile(site_path, [name, <span class="string">&#x27;_FFT.png&#x27;</span>]));</span><br><span class="line">        close;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% —— 计算响应谱矩阵 —— </span></span><br><span class="line">        Sa_matrix = <span class="built_in">zeros</span>(<span class="built_in">numel</span>(damping_ratios), <span class="built_in">numel</span>(T));</span><br><span class="line">        Sv_matrix = Sa_matrix;</span><br><span class="line">        Sd_matrix = Sa_matrix;</span><br><span class="line">        omega = <span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:Nfft<span class="number">-1</span>)/(Nfft*dt);</span><br><span class="line">        Af = fft(acc, Nfft);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">numel</span>(damping_ratios)</span><br><span class="line">            xi = damping_ratios(k);</span><br><span class="line">            Sa = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">numel</span>(T));</span><br><span class="line">            Sv = Sa; Sd = Sa;</span><br><span class="line">            <span class="keyword">for</span> t = <span class="number">1</span>:<span class="built_in">numel</span>(T)</span><br><span class="line">                wn = <span class="number">2</span>*<span class="built_in">pi</span> / T(t);</span><br><span class="line">                H = <span class="number">1</span> ./ (-(omega.^<span class="number">2</span>) + <span class="number">2</span><span class="built_in">i</span>*xi*omega*wn + wn^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                u = <span class="built_in">real</span>(ifft(Af .* H));        </span><br><span class="line">                u = u(<span class="number">1</span>:n);</span><br><span class="line">                v = <span class="built_in">real</span>(ifft(Af .* H .* (<span class="number">1</span><span class="built_in">i</span>*omega))); </span><br><span class="line">                v = v(<span class="number">1</span>:n);</span><br><span class="line">                a_rel = <span class="built_in">real</span>(ifft(-Af .* (omega.^<span class="number">2</span>) .* H)); </span><br><span class="line">                a_rel = a_rel(<span class="number">1</span>:n);</span><br><span class="line">                a_abs = a_rel + acc;</span><br><span class="line"></span><br><span class="line">                Sd(t) = <span class="built_in">max</span>(<span class="built_in">abs</span>(u));</span><br><span class="line">                Sv(t) = <span class="built_in">max</span>(<span class="built_in">abs</span>(v));</span><br><span class="line">                Sa(t) = <span class="built_in">max</span>(<span class="built_in">abs</span>(a_abs)) / g;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            Sa_matrix(k,:) = Sa;</span><br><span class="line">            Sv_matrix(k,:) = Sv;</span><br><span class="line">            Sd_matrix(k,:) = Sd;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        Data = &#123;Sa_matrix, Sv_matrix, Sd_matrix&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% —— 绘制并保存反应谱 —— </span></span><br><span class="line">        <span class="keyword">for</span> p = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">            save_dir = fullfile(site_path, spec_folders&#123;p&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">% — ξ=0 单独绘图 —</span></span><br><span class="line">            <span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,[labels&#123;p&#125;, <span class="string">&#x27; ξ=0 - &#x27;</span>, name],<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">            <span class="built_in">plot</span>(T, Data&#123;p&#125;(<span class="number">1</span>,:), <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">            grid on; xlabel(<span class="string">&#x27;T (s)&#x27;</span>); ylabel(labels&#123;p&#125;);</span><br><span class="line">            title([labels&#123;p&#125;, <span class="string">&#x27; Response Spectrum (ξ=0) - &#x27;</span>, name]);</span><br><span class="line">            <span class="built_in">legend</span>(<span class="string">&quot;ξ=0&quot;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;best&#x27;</span>);</span><br><span class="line">            saveas(gcf, fullfile(save_dir, [name, suffix&#123;p&#125;, <span class="string">&#x27;_damping0.png&#x27;</span>]));</span><br><span class="line">            close;</span><br><span class="line"></span><br><span class="line">            <span class="comment">% — 其他阻尼合并图 —</span></span><br><span class="line">            <span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,[labels&#123;p&#125;, <span class="string">&#x27; ξ&gt;0 - &#x27;</span>, name],<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">            <span class="built_in">hold</span> on; grid on;</span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">2</span>:<span class="built_in">numel</span>(damping_ratios)</span><br><span class="line">                <span class="built_in">plot</span>(T, Data&#123;p&#125;(k,:), <span class="string">&#x27;DisplayName&#x27;</span>,[<span class="string">&#x27;ξ=&#x27;</span>,num2str(damping_ratios(k))]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            xlabel(<span class="string">&#x27;T (s)&#x27;</span>); ylabel(labels&#123;p&#125;);</span><br><span class="line">            title([labels&#123;p&#125;, <span class="string">&#x27; Response Spectrum (ξ=0.01–0.10) - &#x27;</span>, name]);</span><br><span class="line">            <span class="built_in">legend</span>(<span class="string">&#x27;show&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;best&#x27;</span>);</span><br><span class="line">            saveas(gcf, fullfile(save_dir, [name, suffix&#123;p&#125;, <span class="string">&#x27;_dampingOthers.png&#x27;</span>]));</span><br><span class="line">            close;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以地震波RSN4000HNN（PEER编号）为例，不同阻尼比下，单自由度结构绝对加速度反应谱如下图所示。<br><img src="/2025/05/%E5%9C%B0%E9%9C%87%E5%8A%A8%E5%8F%8D%E5%BA%94%E8%B0%B1%E5%88%86%E6%9E%90%E5%8F%8A%E8%AE%A1%E7%AE%97/RSN4000HHN_Sa_dampingOthers.png" alt="不同阻尼比下单自由度结构绝对加速度反应谱"></p>]]></content>
      
      
      <categories>
          
          <category> 结构抗震 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反应谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机地震动生成</title>
      <link href="/2025/05/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E9%9C%87%E5%8A%A8%E7%94%9F%E6%88%90/"/>
      <url>/2025/05/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E9%9C%87%E5%8A%A8%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="随机地震动生成"><a href="#随机地震动生成" class="headerlink" title="随机地震动生成"></a>随机地震动生成</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><h3 id="Clough-Penzien-谱"><a href="#Clough-Penzien-谱" class="headerlink" title="Clough-Penzien 谱"></a>Clough-Penzien 谱</h3><p>Clough-Penzien 谱是由 Clough 和 Penzien 提出的经典地震动功率谱模型，广泛应用于模拟地震动输入的频率特性，特别适用于结构动力分析中的输入地震动建模。它考虑了地震波从基岩到地面传播过程中滤波效应，因此比简单白噪声模型更真实。Clough-Penzien 功率谱的数学表达式为</p>$$S(\omega ) = {{1 + 4{\zeta _g}^2{{\left( {{\omega  \over {{\omega _g}}}} \right)}^2}} \over {{{\left[ {1 - {{\left( {{\omega  \over {{\omega _g}}}} \right)}^2}} \right]}^2} + 4{\zeta _g}^2{{\left( {{\omega  \over {{\omega _g}}}} \right)}^2}}} \cdot {{{{\left( {{\omega  \over {{\omega _s}}}} \right)}^4}} \over {{{\left[ {1 - {{\left( {{\omega  \over {{\omega _s}}}} \right)}^2}} \right]}^2} + 4\zeta _s^2{{\left( {{\omega  \over {{\omega _s}}}} \right)}^2}}}{S_0}$$<p>其中，$S_0$为谱强度因子，一般需要根据PGA来调整，使得模拟得到的加速度时程具有与目标PGA相匹配的峰值，此处取0.005；$\omega _g$和$\zeta _g$分别表示地基土的卓越频率和阻尼比，$\omega _s$和$\zeta _s$分别是高通滤波器的两个参数，它们通过衰减低频分量的功率谱密度，确保地震时程的速度和位移积分具有物理意义，避免出现Kanai-Tajimi谱中位移发散的非物理结果。对于和的取值，陈国兴等学者的研究<sup><a href="#fn_1" id="reffn_1">1</a></sup>指出，取${\xi _s} = {\xi _g}$，${\omega _s} = (0.1\sim0.2) {\omega _g}$。<br>针对四类场地，若要确定其卓越频率，还要考虑设计地震分组，以上海市为例，其设计地震分组为第一组，则四类场地类别的卓越频率如表1所示。取${\omega _s} = 0.1{\omega _g}$，地基土阻尼比${\xi _g}$的值参考文献<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p>表1 四类场地对应的C-P模型参数</p><div class="table-container"><table><thead><tr><th style="text-align:center">场地类别</th><th style="text-align:center">$\omega_g$ (rad/s)</th><th style="text-align:center">$\xi_g$</th><th style="text-align:center">$\omega_s$ (rad/s)</th><th style="text-align:center">$\xi_s$</th></tr></thead><tbody><tr><td style="text-align:center">I₀</td><td style="text-align:center">31.416</td><td style="text-align:center">0.64</td><td style="text-align:center">3.1416</td><td style="text-align:center">0.64</td></tr><tr><td style="text-align:center">II</td><td style="text-align:center">17.952</td><td style="text-align:center">0.72</td><td style="text-align:center">1.7952</td><td style="text-align:center">0.72</td></tr><tr><td style="text-align:center">III</td><td style="text-align:center">13.963</td><td style="text-align:center">0.80</td><td style="text-align:center">1.3963</td><td style="text-align:center">0.80</td></tr><tr><td style="text-align:center">IV</td><td style="text-align:center">9.666</td><td style="text-align:center">0.90</td><td style="text-align:center">0.9666</td><td style="text-align:center">0.90</td></tr></tbody></table></div><p>注：由于Ⅰ类场地包含两个亚类I0和I1，此处仅以I0为例。</p><h3 id="谱表达与随机谐和函数方法"><a href="#谱表达与随机谐和函数方法" class="headerlink" title="谱表达与随机谐和函数方法"></a>谱表达与随机谐和函数方法</h3><p>谱表达方法是一种经典的平稳随机过程模拟方法，其核心思想是利用已知功率谱密度函数 ，通过一组频率分量的叠加，在时域中合成出一个与目标谱相符的地震动时程。谱表达方式通常采用如下形式：<br>$$a(t) = \sum\limits_{i = 1}^N {\sqrt {2S({\omega _i})\Delta \omega } } \cos ({\omega _i}t + {\phi _i})$$<br>其中 $\varphi_i$ 是在 $[0,2\pi]$ 之间均匀分布的独立随机变量，$\omega_i = \omega_{\min} + \left(i - \frac{1} {2} \right) \Delta\omega$。本文取$\omega_l = 0.1 \text{ rad/s},\quad \omega_u = 100 \text{ rad/s},\quad N = 1000,\quad \Delta\omega = \frac{ \omega_u - \omega_l} {N}$。<br>随机谐和函数法在谱表达法基础上考虑频率$\omega_{i}$也为独立随机变量，在$\left[ { {\omega _l},{\omega _u} } \right]$上满足均匀分布。<br>然而上述两种方法得到的是平稳随机过程，需要乘以时间包络函数，得到的地震动时程才能够大体反映地震动的时域非平稳特性。时间包络函数<sup><a href="#fn_3" id="reffn_3">3</a></sup>选取如下：<br>$$f(t) = \begin{cases}\left(\frac{t}{t_1}\right)^2 & 0 \le t \le t_1 \\1 & t_1 \le t \le t_2 \\e^{-c(t-t_2)} & t \ge t_2\end{cases}$$<br>其中，$t_1$ 取 $2\text{ s}$，$t_2$ 取 $15\text{ s}$，$c$ 取 $0.45$。地震动持时 $t_d = 20\text{ s}$。<br>为了验证所生成的地震动时程是否符合Clough-Penzien模型的谱特征，本文将每条模拟加速度时程转换为功率谱密度（PSD），并与目标谱进行对比。本文采用Welch方法（MATLAB中的pwelch()函数）进行PSD估计。Welch方法基本原理是把时程$a(t)$拆分成多个重叠的小段，每段计算其快速傅里叶变换（FFT），然后平方取模，得到每段的功率谱；最后对多个小段进行平均，得到平滑的PSD估计值。</p><h2 id="生成地震动加速度时程及其PSD"><a href="#生成地震动加速度时程及其PSD" class="headerlink" title="生成地震动加速度时程及其PSD"></a>生成地震动加速度时程及其PSD</h2><p>本文基于Clough-Penzien谱利用MATLAB，针对四类场地，生成10条随机地震动，同时绘制其PSD曲线与目标谱进行对比，相应代码如下。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 通用参数</span></span><br><span class="line">N          = <span class="number">1000</span>;      <span class="comment">% 频率离散点数</span></span><br><span class="line">dt         = <span class="number">0.001</span>;     <span class="comment">% 时间步长 (s)</span></span><br><span class="line">T          = <span class="number">20</span>;        <span class="comment">% 总时长 (s)</span></span><br><span class="line">t          = <span class="number">0</span>:dt:T;    <span class="comment">% 时间向量</span></span><br><span class="line">omega_min  = <span class="number">0.1</span>;        <span class="comment">% 最小角频率 (rad/s)</span></span><br><span class="line">omega_max  = <span class="number">100</span>;        <span class="comment">% 最大角频率 (rad/s)</span></span><br><span class="line">S0         = <span class="number">0.005</span>;          <span class="comment">% 归一化常数</span></span><br><span class="line">numReals   = <span class="number">10</span>;         <span class="comment">% 每种方法生成的随机地震条数</span></span><br><span class="line">fs         = <span class="number">1</span>/dt;       <span class="comment">% 采样频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 四类场地 Clough-Penzien 谱参数</span></span><br><span class="line">siteClasses = &#123;<span class="string">&#x27;I0&#x27;</span>,<span class="string">&#x27;II&#x27;</span>,<span class="string">&#x27;III&#x27;</span>,<span class="string">&#x27;IV&#x27;</span>&#125;;</span><br><span class="line">CP = struct();</span><br><span class="line">CP.I0  = struct(<span class="string">&#x27;omega_g&#x27;</span>,<span class="number">31.416</span>,<span class="string">&#x27;zeta_g&#x27;</span>,<span class="number">0.64</span>,<span class="string">&#x27;omega_s&#x27;</span>,<span class="number">3.1416</span>,<span class="string">&#x27;zeta_s&#x27;</span>,<span class="number">0.64</span>);</span><br><span class="line">CP.II  = struct(<span class="string">&#x27;omega_g&#x27;</span>,<span class="number">17.952</span>,<span class="string">&#x27;zeta_g&#x27;</span>,<span class="number">0.72</span>,<span class="string">&#x27;omega_s&#x27;</span>,<span class="number">1.7952</span>,<span class="string">&#x27;zeta_s&#x27;</span>,<span class="number">0.72</span>);</span><br><span class="line">CP.III = struct(<span class="string">&#x27;omega_g&#x27;</span>,<span class="number">13.963</span>,<span class="string">&#x27;zeta_g&#x27;</span>,<span class="number">0.80</span>,<span class="string">&#x27;omega_s&#x27;</span>,<span class="number">1.3963</span>,<span class="string">&#x27;zeta_s&#x27;</span>,<span class="number">0.80</span>);</span><br><span class="line">CP.IV  = struct(<span class="string">&#x27;omega_g&#x27;</span>,<span class="number">9.666</span>,<span class="string">&#x27;zeta_g&#x27;</span>,<span class="number">0.90</span>,<span class="string">&#x27;omega_s&#x27;</span>,<span class="number">0.9666</span>,<span class="string">&#x27;zeta_s&#x27;</span>,<span class="number">0.90</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建保存目录</span></span><br><span class="line">baseDir = fullfile(pwd,<span class="string">&#x27;地震动模拟结果&#x27;</span>);</span><br><span class="line">folders = &#123;fullfile(baseDir,<span class="string">&#x27;地震动时程&#x27;</span>), fullfile(baseDir,<span class="string">&#x27;PSD&#x27;</span>)&#125;;</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(folders)</span><br><span class="line">    <span class="keyword">if</span> ~exist(folders&#123;k&#125;,<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">        mkdir(folders&#123;k&#125;);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 目标谱函数句柄</span></span><br><span class="line">SY_fun = @(w,cp) (<span class="number">1</span>+<span class="number">4</span>*cp.zeta_g^<span class="number">2</span>*(w/cp.omega_g).^<span class="number">2</span>)./((<span class="number">1</span>-(w/cp.omega_g).^<span class="number">2</span>).^<span class="number">2</span>+<span class="number">4</span>*cp.zeta_g^<span class="number">2</span>*(w/cp.omega_g).^<span class="number">2</span>) .* ...</span><br><span class="line">                 ((w/cp.omega_s).^<span class="number">4.</span>/((<span class="number">1</span>-(w/cp.omega_s).^<span class="number">2</span>).^<span class="number">2</span>+<span class="number">4</span>*cp.zeta_s^<span class="number">2</span>*(w/cp.omega_s).^<span class="number">2</span>))*S0;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 主循环：场地类别</span></span><br><span class="line"><span class="keyword">for</span> s = <span class="number">1</span>:<span class="built_in">length</span>(siteClasses)</span><br><span class="line">    site = siteClasses&#123;s&#125;;</span><br><span class="line">    cp = CP.(site);</span><br><span class="line">    <span class="comment">% 频谱离散</span></span><br><span class="line">    delta_omega = (omega_max-omega_min)/N;</span><br><span class="line">    omega = omega_min + ( (<span class="number">1</span>:N)<span class="number">-0.5</span> )*delta_omega;</span><br><span class="line">    sy_target = SY_fun(omega,cp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 存 PSD 目录</span></span><br><span class="line">    psdDir = fullfile(baseDir,<span class="string">&#x27;PSD&#x27;</span>,site);</span><br><span class="line">    <span class="keyword">if</span> ~exist(psdDir,<span class="string">&#x27;dir&#x27;</span>), mkdir(psdDir); <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 存时程目录</span></span><br><span class="line">    accDir_spec = fullfile(baseDir,<span class="string">&#x27;地震动时程&#x27;</span>,site,<span class="string">&#x27;spectrum&#x27;</span>);</span><br><span class="line">    accDir_harm = fullfile(baseDir,<span class="string">&#x27;地震动时程&#x27;</span>,site,<span class="string">&#x27;harmonic&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ~exist(accDir_spec,<span class="string">&#x27;dir&#x27;</span>), mkdir(accDir_spec); <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~exist(accDir_harm,<span class="string">&#x27;dir&#x27;</span>), mkdir(accDir_harm); <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 生成多条</span></span><br><span class="line">    <span class="keyword">for</span> method = &#123;<span class="string">&#x27;spectrum&#x27;</span>,<span class="string">&#x27;harmonic&#x27;</span>&#125;</span><br><span class="line">        m = method&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:numReals</span><br><span class="line">            <span class="comment">% 随机相位与频率</span></span><br><span class="line">            <span class="keyword">switch</span> m</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;spectrum&#x27;</span></span><br><span class="line">                    phi = <span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,N);</span><br><span class="line">                    A = <span class="built_in">sqrt</span>(<span class="number">2</span>*SY_fun(omega,cp)*delta_omega);</span><br><span class="line">                    acc = <span class="built_in">zeros</span>(<span class="built_in">size</span>(t));</span><br><span class="line">                    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">                        acc = acc + A(<span class="built_in">i</span>) * <span class="built_in">cos</span>(omega(<span class="built_in">i</span>) * t + phi(<span class="built_in">i</span>));</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;harmonic&#x27;</span></span><br><span class="line">                    omega_r = <span class="built_in">sort</span>(omega_min + (omega_max-omega_min)*<span class="built_in">rand</span>(<span class="number">1</span>,N));</span><br><span class="line">                    delta_omega_r = diff([omega_r,omega_max]);</span><br><span class="line">                    phi_r = <span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,N);</span><br><span class="line">                    A_r = <span class="built_in">sqrt</span>(<span class="number">2</span>*SY_fun(omega_r,cp).*delta_omega_r);</span><br><span class="line">                    acc = <span class="built_in">zeros</span>(<span class="built_in">size</span>(t));</span><br><span class="line">                    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">                        acc = acc + A(<span class="built_in">i</span>) * <span class="built_in">cos</span>(omega(<span class="built_in">i</span>) * t + phi(<span class="built_in">i</span>));</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">% 包络</span></span><br><span class="line">            t1=<span class="number">2</span>; t2=<span class="number">15</span>; c=<span class="number">0.45</span>; fenv=<span class="built_in">zeros</span>(<span class="built_in">size</span>(t));</span><br><span class="line">            fenv(t&lt;=t1)=(t(t&lt;=t1)/t1).^<span class="number">2</span>;</span><br><span class="line">            fenv(t&gt;t1 &amp; t&lt;=t2)=<span class="number">1</span>;</span><br><span class="line">            fenv(t&gt;t2)=<span class="built_in">exp</span>(-c*(t(t&gt;t2)-t2));</span><br><span class="line">            acc = acc.*fenv;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% 保存时程 MAT 和图像</span></span><br><span class="line">            fn = sprintf(<span class="string">&#x27;%s_%s_%02d&#x27;</span>,site,m,k);</span><br><span class="line">            save(fullfile(baseDir,<span class="string">&#x27;地震动时程&#x27;</span>,site,m,[fn <span class="string">&#x27;.mat&#x27;</span>]),<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;acc&#x27;</span>);</span><br><span class="line">            <span class="built_in">figure</span>(<span class="string">&#x27;Visible&#x27;</span>,<span class="string">&#x27;off&#x27;</span>); </span><br><span class="line">            <span class="built_in">plot</span>(t,acc); </span><br><span class="line">            xlabel(<span class="string">&#x27;t(s)&#x27;</span>); </span><br><span class="line">            ylabel(<span class="string">&#x27;a(m/s^2)&#x27;</span>);</span><br><span class="line">            title([<span class="string">&#x27;Acceleration - &#x27;</span> site <span class="string">&#x27; - &#x27;</span> m <span class="string">&#x27; - #&#x27;</span> num2str(k)]);</span><br><span class="line">            saveas(gcf,fullfile(baseDir,<span class="string">&#x27;地震动时程&#x27;</span>,site,m,[fn <span class="string">&#x27;.png&#x27;</span>])); </span><br><span class="line">            close;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% PSD 对比（以第一条为例）</span></span><br><span class="line">    <span class="comment">% 读取第一条</span></span><br><span class="line">    d1 = load(fullfile(accDir_spec,[site <span class="string">&#x27;_spectrum_01.mat&#x27;</span>])); acc1=d1.acc;</span><br><span class="line">    d2 = load(fullfile(accDir_harm ,[site <span class="string">&#x27;_harmonic_01.mat&#x27;</span>])); acc2=d2.acc;</span><br><span class="line">    <span class="comment">% 计算 PSD</span></span><br><span class="line">    [psd1,f] = pwelch(acc1,[],[],[],fs);</span><br><span class="line">    [psd2,~] = pwelch(acc2,[],[],[],fs);</span><br><span class="line">    w = <span class="number">2</span>*<span class="built_in">pi</span>*f;</span><br><span class="line">    valid = w&gt;=omega_min &amp; w&lt;=omega_max;</span><br><span class="line">    <span class="comment">% 绘图保存</span></span><br><span class="line">    <span class="built_in">figure</span>(<span class="string">&#x27;Visible&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line">    <span class="built_in">plot</span>(w(valid),psd1(valid)/(<span class="number">2</span>*<span class="built_in">pi</span>),<span class="string">&#x27;m-&#x27;</span>,<span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;谱表达法&#x27;</span>); </span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(w(valid),psd2(valid)/(<span class="number">2</span>*<span class="built_in">pi</span>),<span class="string">&#x27;b--&#x27;</span>,<span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;随机谐和函数法&#x27;</span>);</span><br><span class="line">    <span class="built_in">plot</span>(omega,sy_target,<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;C-P 目标谱&#x27;</span>);</span><br><span class="line">    <span class="built_in">legend</span>; </span><br><span class="line">    xlabel(<span class="string">&#x27;\omega (rad/s)&#x27;</span>); </span><br><span class="line">    ylabel(<span class="string">&#x27;PSD (m^2/s^3)&#x27;</span>);</span><br><span class="line">    title([<span class="string">&#x27;PSD Comparison - &#x27;</span> site]);</span><br><span class="line">    grid on; </span><br><span class="line">    xlim([omega_min omega_max]);</span><br><span class="line">    saveas(gcf,fullfile(psdDir,[<span class="string">&#x27;PSD_&#x27;</span> site <span class="string">&#x27;.png&#x27;</span>]));</span><br><span class="line">    close;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>I0类场地下谱表达法生成的随机地震动：<br><img src="/2025/05/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E9%9C%87%E5%8A%A8%E7%94%9F%E6%88%90/I0类场地下谱表达法生成的随机地震动.png" alt="I0类场地下谱表达法生成的随机地震动"></p><p>I0类场地下谱表达法和随机谐和函数法获得的结果与目标谱对比：</p><p><img src="/2025/05/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E9%9C%87%E5%8A%A8%E7%94%9F%E6%88%90/I0类场地下谱表达法和随机谐和函数法获得的结果与目标谱对比.png" alt="I0类场地下谱表达法和随机谐和函数法获得的结果与目标谱对比"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote id="fn_1"><sup>1</sup>. 陈国兴, 金永彬, 宰金珉. 高层建筑随机地震反应的简捷计算[J]. 南京建筑工程学院学报, 1999, (01): 31-39.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. 张治勇, 孙柏涛, 宋天舒. 新抗震规范地震动功率谱模型参数的研究[J]. 世界地震工程, 2000, (03): 33-38.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. AMIN M, ANG A H S. Nonstationary stochastic model of earthquake motion[J]. Journal of the Engineering Mechanics Division, ASCE, 1968, 94(EM2): 559-584.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 结构抗震 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地震动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU命名规则</title>
      <link href="/2025/04/CPU%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
      <url>/2025/04/CPU%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="🟥-AMD-Ryzen-CPU-命名规则（适用于-7000-系列及以后）"><a href="#🟥-AMD-Ryzen-CPU-命名规则（适用于-7000-系列及以后）" class="headerlink" title="🟥 AMD Ryzen CPU 命名规则（适用于 7000 系列及以后）"></a>🟥 AMD Ryzen CPU 命名规则（适用于 7000 系列及以后）</h1><h2 id="✅-命名结构"><a href="#✅-命名结构" class="headerlink" title="✅ 命名结构"></a>✅ 命名结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ryzen <span class="selector-attr">[系列]</span> <span class="selector-attr">[四位数字型号]</span> <span class="selector-attr">[后缀]</span></span><br><span class="line">示例：Ryzen <span class="number">7</span> <span class="number">7840</span>HS</span><br></pre></td></tr></table></figure><h2 id="🔢-四位数字型号解析（7840）"><a href="#🔢-四位数字型号解析（7840）" class="headerlink" title="🔢 四位数字型号解析（7840）"></a>🔢 四位数字型号解析（7840）</h2><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">数字</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center">第1位</td><td style="text-align:center">7</td><td style="text-align:left">产品系列（发布年份）</td><td style="text-align:left">7 → 7000 系列（约 2023 年发布）</td></tr><tr><td style="text-align:center">第2位</td><td style="text-align:center">8</td><td style="text-align:left">架构代数（Zen 架构版本）</td><td style="text-align:left">8 → Zen 4，7 → Zen 3+，6 → Zen 3，5 → Zen 2</td></tr><tr><td style="text-align:center">第3位</td><td style="text-align:center">4</td><td style="text-align:left">子系列性能等级</td><td style="text-align:left">数字越高，性能越强</td></tr><tr><td style="text-align:center">第4位</td><td style="text-align:center">0</td><td style="text-align:left">细分型号</td><td style="text-align:left">通常为 0，表示标准版本</td></tr></tbody></table></div><h2 id="🔤-后缀说明"><a href="#🔤-后缀说明" class="headerlink" title="🔤 后缀说明"></a>🔤 后缀说明</h2><div class="table-container"><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:left">含义</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:left">高性能桌面版，支持超频</td></tr><tr><td style="text-align:center">G</td><td style="text-align:left">带集成显卡的桌面版</td></tr><tr><td style="text-align:center">GE</td><td style="text-align:left">低功耗桌面版（带核显）</td></tr><tr><td style="text-align:center">H</td><td style="text-align:left">高性能笔记本版（45W）</td></tr><tr><td style="text-align:center">HS</td><td style="text-align:left">高性能省电笔记本版（35W）</td></tr><tr><td style="text-align:center">HX</td><td style="text-align:left">极致性能笔记本版（可超频）</td></tr><tr><td style="text-align:center">U</td><td style="text-align:left">低功耗笔记本版（15-28W）</td></tr><tr><td style="text-align:center">C</td><td style="text-align:left">Chromebook 专用版</td></tr><tr><td style="text-align:center">E</td><td style="text-align:left">超低功耗版本（移动端）</td></tr><tr><td style="text-align:center">PRO</td><td style="text-align:left">企业版，具备额外安全与管理特性</td></tr></tbody></table></div><h2 id="📝-示例解析"><a href="#📝-示例解析" class="headerlink" title="📝 示例解析"></a>📝 示例解析</h2><ul><li><strong>Ryzen 7 7840HS</strong>：7000 系列，Zen 4 架构，中高端性能，35W 高性能省电笔记本版。</li><li><strong>Ryzen 5 7520U</strong>：7000 系列，Zen 2 架构，入门级性能，低功耗笔记本版。</li></ul><hr><h1 id="🟦-Intel-Core-i-系列命名规则（第1代至第13代）"><a href="#🟦-Intel-Core-i-系列命名规则（第1代至第13代）" class="headerlink" title="🟦 Intel Core i 系列命名规则（第1代至第13代）"></a>🟦 Intel Core i 系列命名规则（第1代至第13代）</h1><h2 id="✅-命名结构-1"><a href="#✅-命名结构-1" class="headerlink" title="✅ 命名结构"></a>✅ 命名结构</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intel Core [<span class="type">i3</span>/<span class="type">i5</span>/<span class="type">i7</span>/<span class="type">i9</span>] [四/五位数字型号] [后缀]</span><br><span class="line">示例：Intel Core <span class="type">i7</span><span class="number">-12700</span>K</span><br></pre></td></tr></table></figure><h2 id="🔢-型号解析（以-i7-12700K-为例）"><a href="#🔢-型号解析（以-i7-12700K-为例）" class="headerlink" title="🔢 型号解析（以 i7-12700K 为例）"></a>🔢 型号解析（以 i7-12700K 为例）</h2><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">数字/字母</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center">i7</td><td style="text-align:center">性能等级</td><td style="text-align:left">i3（入门），i5（主流），i7（高端），i9（旗舰）</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">代数（第12代）</td><td style="text-align:left">表示第12代 Alder Lake 架构</td></tr><tr><td style="text-align:center">700</td><td style="text-align:center">SKU 编号</td><td style="text-align:left">数字越高，性能越强</td></tr><tr><td style="text-align:center">K</td><td style="text-align:center">后缀</td><td style="text-align:left">表示可超频版本</td></tr></tbody></table></div><h2 id="🔤-常见后缀说明"><a href="#🔤-常见后缀说明" class="headerlink" title="🔤 常见后缀说明"></a>🔤 常见后缀说明</h2><div class="table-container"><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:left">含义</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">K</td><td style="text-align:left">可超频桌面版</td></tr><tr><td style="text-align:center">KF</td><td style="text-align:left">可超频桌面版，无集成显卡</td></tr><tr><td style="text-align:center">F</td><td style="text-align:left">无集成显卡</td></tr><tr><td style="text-align:center">T</td><td style="text-align:left">低功耗桌面版</td></tr><tr><td style="text-align:center">H</td><td style="text-align:left">高性能笔记本版（45W）</td></tr><tr><td style="text-align:center">HK</td><td style="text-align:left">高性能可超频笔记本版</td></tr><tr><td style="text-align:center">U</td><td style="text-align:left">低功耗笔记本版（15-28W）</td></tr><tr><td style="text-align:center">Y</td><td style="text-align:left">超低功耗笔记本版（9W）</td></tr><tr><td style="text-align:center">G1-G7</td><td style="text-align:left">第10/11代移动版，表示集成显卡等级</td></tr></tbody></table></div><h2 id="📝-示例解析-1"><a href="#📝-示例解析-1" class="headerlink" title="📝 示例解析"></a>📝 示例解析</h2><ul><li><strong>Intel Core i5-10400F</strong>：第10代，主流性能，无集成显卡，适合预算有限的用户。</li><li><strong>Intel Core i7-12700K</strong>：第12代，高端性能，可超频，适合高性能需求的用户。</li><li><strong>Intel Core i9-11900K</strong>：第11代，旗舰性能，可超频，适合极致性能需求的用户。</li></ul><hr><h1 id="🟦-Intel-Core-Core-Ultra-CPU-命名规则（第14代及以后）"><a href="#🟦-Intel-Core-Core-Ultra-CPU-命名规则（第14代及以后）" class="headerlink" title="🟦 Intel Core / Core Ultra CPU 命名规则（第14代及以后）"></a>🟦 Intel Core / Core Ultra CPU 命名规则（第14代及以后）</h1><h2 id="✅-命名结构-2"><a href="#✅-命名结构-2" class="headerlink" title="✅ 命名结构"></a>✅ 命名结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intel Core <span class="selector-attr">[3/5/7/9]</span> <span class="selector-attr">[型号]</span> <span class="selector-attr">[后缀]</span></span><br><span class="line">Intel Core Ultra <span class="selector-attr">[5/7/9]</span> <span class="selector-attr">[型号]</span> <span class="selector-attr">[后缀]</span></span><br><span class="line">示例：Intel Core Ultra <span class="number">7</span> <span class="number">165</span>H</span><br></pre></td></tr></table></figure><h2 id="🔢-型号解析（以-Core-Ultra-7-165H-为例）"><a href="#🔢-型号解析（以-Core-Ultra-7-165H-为例）" class="headerlink" title="🔢 型号解析（以 Core Ultra 7 165H 为例）"></a>🔢 型号解析（以 Core Ultra 7 165H 为例）</h2><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">数字/字母</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center">Core Ultra 7</td><td style="text-align:center">品牌与性能等级</td><td style="text-align:left">Core（主流），Core Ultra（高端）；数字越大，性能越强</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">系列代数（Series Number）</td><td style="text-align:left">1 → 第1代（Meteor Lake）</td></tr><tr><td style="text-align:center">65</td><td style="text-align:center">SKU 编号</td><td style="text-align:left">数字越高，性能越强</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">后缀</td><td style="text-align:left">高性能笔记本版（45W）</td></tr></tbody></table></div><h2 id="🔤-常见后缀说明-1"><a href="#🔤-常见后缀说明-1" class="headerlink" title="🔤 常见后缀说明"></a>🔤 常见后缀说明</h2><div class="table-container"><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:left">含义</th><th style="text-align:left">功耗范围</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:left">高性能笔记本版</td><td style="text-align:left">45W</td></tr><tr><td style="text-align:center">U</td><td style="text-align:left">低功耗笔记本版</td><td style="text-align:left">15-28W</td></tr><tr><td style="text-align:center">K</td><td style="text-align:left">可超频桌面版</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">F</td><td style="text-align:left">无集成显卡</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">HX</td><td style="text-align:left">极致性能笔记本版</td><td style="text-align:left">55W 以上</td></tr></tbody></table></div><h2 id="📝-示例解析-2"><a href="#📝-示例解析-2" class="headerlink" title="📝 示例解析"></a>📝 示例解析</h2><ul><li><strong>Intel Core Ultra 7 165H</strong>：第1代 Core Ultra 系列，SKU 为 65，高性能笔记本版（45W）。</li><li><strong>Intel Core 5 120U</strong>：第1代 Core 系列，SKU 为 20，低功耗笔记本版（15-28W）。</li></ul><hr><h1 id="🔄-Intel-CPU-命名规则对比"><a href="#🔄-Intel-CPU-命名规则对比" class="headerlink" title="🔄 Intel CPU 命名规则对比"></a>🔄 Intel CPU 命名规则对比</h1><div class="table-container"><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:left">第1-13代（Core i 系列）</th><th style="text-align:left">第14代及以后（Core / Core Ultra 系列）</th></tr></thead><tbody><tr><td style="text-align:center">品牌命名</td><td style="text-align:left">Core i3 / i5 / i7 / i9</td><td style="text-align:left">Core 3 / 5 / 7 / 9；Core Ultra 5 / 7 / 9</td></tr><tr><td style="text-align:center">架构代数表示</td><td style="text-align:left">型号中的前两位数字</td><td style="text-align:left">型号中的第1位数字（Series Number）</td></tr><tr><td style="text-align:center">后缀</td><td style="text-align:left">K, F, T, H, U, Y, G1-G7 等</td><td style="text-align:left">H, U, K, F, HX 等</td></tr><tr><td style="text-align:center">适用平台</td><td style="text-align:left">桌面与移动端</td><td style="text-align:left">桌面与移动端</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用QQ发消息讲清网络通信基础</title>
      <link href="/2025/03/01%E7%A7%91%E6%99%AE-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/03/01%E7%A7%91%E6%99%AE-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="QQ消息传输的计算机网络分层解析"><a href="#QQ消息传输的计算机网络分层解析" class="headerlink" title="QQ消息传输的计算机网络分层解析"></a>QQ消息传输的计算机网络分层解析</h1><h2 id="一、发送端（用户1发消息）"><a href="#一、发送端（用户1发消息）" class="headerlink" title="一、发送端（用户1发消息）"></a><strong>一、发送端（用户1发消息）</strong></h2><p>用户1打开QQ，输入“你最近过得好吗？”，点击发送。这条消息会从<strong>应用层</strong>开始，逐步向下封装，最终变成一个个数据包在互联网中传输。</p><h3 id="1-应用层（Application-Layer）"><a href="#1-应用层（Application-Layer）" class="headerlink" title="1. 应用层（Application Layer）"></a><strong>1. 应用层（Application Layer）</strong></h3><ul><li>QQ应用（应用层）会按照自己的<strong>通信协议</strong>（例如消息格式、用户ID、好友列表等）封装这条文本消息。</li><li>这时候，消息是<strong>“纯文本数据”</strong>，应用层协议会加上自己的头部信息，例如：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[应用层头部] + <span class="string">&quot;你最近过得好吗？&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-传输层（Transport-Layer）"><a href="#2-传输层（Transport-Layer）" class="headerlink" title="2. 传输层（Transport Layer）"></a><strong>2. 传输层（Transport Layer）</strong></h3><ul><li>传输层的作用是<strong>确保端到端的可靠传输</strong>。QQ通常使用 <strong>TCP协议</strong>，提供：<ul><li><strong>数据分段</strong>（如果消息太大，TCP会把它拆成多个小块）</li><li><strong>编号排序</strong>（确保数据按顺序到达）</li><li><strong>丢包重传</strong>（如果丢失，TCP会重传）</li></ul></li><li>TCP会给数据加上 <strong>传输层头部</strong>，包括：<ul><li><strong>源端口</strong>（用户1的QQ客户端端口号）</li><li><strong>目标端口</strong>（QQ服务器的端口号）</li><li><strong>序列号</strong>（数据包编号）</li><li><strong>校验和</strong>（确保数据没损坏）</li></ul></li></ul><p>🔹 <strong>封装后</strong>：<br>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[传输层头部] + [应用层头部] + <span class="string">&quot;你最近过得好吗？&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-网络层（Network-Layer）"><a href="#3-网络层（Network-Layer）" class="headerlink" title="3. 网络层（Network Layer）"></a><strong>3. 网络层（Network Layer）</strong></h3><ul><li>传输层的数据虽然已经准备好，但它并不知道怎么到QQ服务器，所以需要 <strong>网络层（IP协议）</strong> 来帮忙！</li><li><strong>IP协议</strong> 负责：<ul><li><strong>寻找路径（路由选择）</strong></li><li><strong>封装IP地址</strong>（源IP：用户1的电脑，目标IP：QQ服务器）</li></ul></li><li><strong>网络层头部</strong> 会被加到数据包前面：<ul><li><strong>源IP地址</strong>（用户1的设备的IP）</li><li><strong>目标IP地址</strong>（QQ服务器的IP）</li><li><strong>TTL（生存时间，防止数据包无限循环）</strong></li></ul></li></ul><p>🔹 <strong>封装后</strong>：<br>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[网络层头部] + [传输层头部] + [应用层头部] + <span class="string">&quot;你最近过得好吗？&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="4-数据链路层（Data-Link-Layer）"><a href="#4-数据链路层（Data-Link-Layer）" class="headerlink" title="4. 数据链路层（Data Link Layer）"></a><strong>4. 数据链路层（Data Link Layer）</strong></h3><ul><li><strong>数据链路层</strong> 负责局部网络传输，使用 MAC 地址来识别设备。</li><li>这时候，数据链路层会加上 <strong>MAC 头部</strong>（例如，目标MAC是路由器的MAC地址）。</li></ul><p>🔹 <strong>最终封装</strong>：<br>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[数据链路层头部] + [网络层头部] + [传输层头部] + [应用层头部] + <span class="string">&quot;你最近过得好吗？&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="5-物理层（Physical-Layer）"><a href="#5-物理层（Physical-Layer）" class="headerlink" title="5. 物理层（Physical Layer）"></a><strong>5. 物理层（Physical Layer）</strong></h3><ul><li>数据被转换成<strong>电信号（有线）或无线信号（WiFi）</strong>，开始传输！</li><li>通过网线、光纤、WiFi 发送到路由器，然后逐步传输到 QQ 服务器。</li></ul><hr><h2 id="二、中途传输（数据在网络中流动）"><a href="#二、中途传输（数据在网络中流动）" class="headerlink" title="二、中途传输（数据在网络中流动）"></a><strong>二、中途传输（数据在网络中流动）</strong></h2><p>数据会经过多个路由器，每经过一个路由器，都要<strong>重新封装数据链路层头部</strong>：</p><ol><li><strong>物理层</strong>：从电信号转换回数据包。</li><li><strong>数据链路层</strong>：检查 MAC 地址，确定下一跳。</li><li><strong>网络层</strong>：检查目标 IP，决定最佳路由。</li><li><strong>数据链路层</strong>：换上新的 MAC 地址，发送到下一个路由器。</li><li><strong>物理层</strong>：转换成信号，继续传输。</li></ol><p>这个过程会持续，直到数据到达 <strong>QQ服务器</strong>。</p><hr><h2 id="三、服务器接收（QQ服务器处理）"><a href="#三、服务器接收（QQ服务器处理）" class="headerlink" title="三、服务器接收（QQ服务器处理）"></a><strong>三、服务器接收（QQ服务器处理）</strong></h2><ol><li><strong>物理层</strong>：QQ服务器收到信号，转换成数据包。</li><li><strong>数据链路层</strong>：检查MAC地址，确认自己是目的地。</li><li><strong>网络层</strong>：检查IP地址，确定是给自己发的。</li><li><strong>传输层</strong>：TCP解析数据，组装成完整的消息。</li><li><strong>应用层</strong>：QQ服务器解析消息，并准备转发给用户2。</li></ol><hr><h2 id="四、服务器转发消息给用户2"><a href="#四、服务器转发消息给用户2" class="headerlink" title="四、服务器转发消息给用户2"></a><strong>四、服务器转发消息给用户2</strong></h2><ul><li>服务器会按照相同的封装方式，再走一遍：<ul><li><strong>传输层（TCP）</strong></li><li><strong>网络层（IP）</strong></li><li><strong>数据链路层（MAC）</strong></li><li><strong>物理层（电信号）</strong></li></ul></li><li>直到数据包到达 <strong>用户2的设备</strong>，再逐层解封装，最终出现在 <strong>QQ聊天窗口里</strong>！</li></ul><hr><h2 id="五、总结：传输层和网络层的关系"><a href="#五、总结：传输层和网络层的关系" class="headerlink" title="五、总结：传输层和网络层的关系"></a><strong>五、总结：传输层和网络层的关系</strong></h2><ul><li><strong>传输层（Transport Layer）</strong> 负责 <strong>端到端</strong> 的可靠传输，它关心的是 <strong>应用和应用之间的通信</strong>，比如 <strong>用户1的QQ 和 用户2的QQ</strong>。</li><li><strong>网络层（Network Layer）</strong> 负责 <strong>找到路径</strong>，它关心的是 <strong>设备和设备之间的通信</strong>，比如 <strong>用户1的电脑 和 QQ服务器</strong>，或者 <strong>服务器 和 用户2的设备</strong>。</li></ul><p>💡 <strong>简单理解</strong>：</p><ul><li>传输层 = <strong>“你写了一封信，确保字迹清晰、不会丢失”</strong></li><li>网络层 = <strong>“邮局帮你找最优的送信路线”</strong></li><li>数据链路层 = <strong>“快递员送信给最近的中转站”</strong></li><li>物理层 = <strong>“真正的传输方式（车、飞机、WiFi信号）”</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构动力响应求解——时域与频域方法对比</title>
      <link href="/2025/02/01%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2025/02/01%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>地震波:<a href="./01时域与频域计算方法/ElCentro.txt">ELCentro</a><br>对于时域方法，可参考我上篇博客，主要有杜哈梅积分、中心差分法和Newmark-β法等；而对于频域方法，是通过正逆傅里叶变换加频响函数H(w)来实现的，具体原理如下图所示。<br><img src="/2025/02/01%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/频域计算基本思路.jpg" alt="频域计算基本思路"><br><img src="/2025/02/01%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/频域计算实际步骤.jpg" alt="频域计算实际步骤"></p><p>Matlab实现：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结构参数</span></span><br><span class="line">m = <span class="number">120</span>;       <span class="comment">% 质量 (t) </span></span><br><span class="line">k = <span class="number">3e5</span>;       <span class="comment">% 刚度 (N/mm)</span></span><br><span class="line">w = <span class="built_in">sqrt</span>(k/m); <span class="comment">% 结构自振频率 (rad/s)</span></span><br><span class="line">kesi = <span class="number">0.05</span>;   <span class="comment">% 阻尼比</span></span><br><span class="line">c = <span class="number">2</span> * m * w * kesi;  <span class="comment">% 阻尼系数 (N·s/mm)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 读取地震加速度数据</span></span><br><span class="line">time_step = <span class="number">0.005</span>;           <span class="comment">% 采样间隔 (s)</span></span><br><span class="line">ground_acc_data = load(<span class="string">&#x27;ElCentro.txt&#x27;</span>);  <span class="comment">% 读取加速度数据</span></span><br><span class="line"><span class="comment">% 将地震加速度（假设单位为 g）转换为惯性力 (N)</span></span><br><span class="line"><span class="comment">% 注意：9.8 表示重力加速度 (m/s^2)，乘 1e3 是为了与 k (N/mm) 单位匹配</span></span><br><span class="line">F_t = - m * ground_acc_data * <span class="number">9.8</span> * <span class="number">1e3</span>;  <span class="comment">% 地面作用力</span></span><br><span class="line">N = <span class="built_in">length</span>(F_t);             <span class="comment">% 采样点数</span></span><br><span class="line">time = (<span class="number">0</span>:N<span class="number">-1</span>) * time_step;  <span class="comment">% 时间向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 频域方法计算相对位移</span></span><br><span class="line"><span class="comment">% 计算 FFT（快速傅里叶变换）</span></span><br><span class="line">F_Ft = fft(F_t);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构造对应的角频率向量（本质是因为Nyquist频率）</span></span><br><span class="line">halfN = <span class="built_in">floor</span>(N/<span class="number">2</span>); <span class="comment">% 统一处理偶数和奇数情况</span></span><br><span class="line">omega = <span class="number">2</span>*<span class="built_in">pi</span>*[<span class="number">0</span>:halfN, -halfN:<span class="number">-1</span>]&#x27;/(N*time_step);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算频响函数 H(omega)</span></span><br><span class="line">H_omega = <span class="number">1</span> ./ (-m*omega.^<span class="number">2</span> + <span class="number">1</span><span class="built_in">i</span>*c*omega + k);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算位移的频谱：X(omega) = H(omega)*F(omega)</span></span><br><span class="line">X_fft = H_omega .* F_Ft;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆 FFT 得到时域相对位移响应</span></span><br><span class="line">x_freq = ifft(X_fft, <span class="string">&#x27;symmetric&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制频域得到的相对位移频谱（仅显示正频率部分）</span></span><br><span class="line">f = (<span class="number">0</span>:halfN<span class="number">-1</span>)&#x27;/(N*time_step);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(X_fft(<span class="number">1</span>:halfN)));</span><br><span class="line">title(<span class="string">&#x27;相对位移频谱&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;频率 (Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;幅值&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">saveas(gcf,<span class="string">&quot;./结构相对位移频谱.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用 Newmark-β 法进行时域计算（平均加速度法：beta=1/4, gamma=1/2）</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">1</span>/<span class="number">4</span>;</span><br><span class="line"><span class="built_in">gamma</span> = <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line">dt = time_step;</span><br><span class="line">T = N;  <span class="comment">% 时间步数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化响应变量</span></span><br><span class="line">x_newmark = <span class="built_in">zeros</span>(T, <span class="number">1</span>);  <span class="comment">% 位移 (mm)</span></span><br><span class="line">v_newmark = <span class="built_in">zeros</span>(T, <span class="number">1</span>);  <span class="comment">% 速度 (mm/s)</span></span><br><span class="line">a_newmark = <span class="built_in">zeros</span>(T, <span class="number">1</span>);  <span class="comment">% 加速度 (mm/s^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始条件（假设初始位移和速度为零）</span></span><br><span class="line">x_newmark(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">v_newmark(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">a_newmark(<span class="number">1</span>) = (F_t(<span class="number">1</span>) - c*v_newmark(<span class="number">1</span>) - k*x_newmark(<span class="number">1</span>)) / m;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 预先计算有效刚度</span></span><br><span class="line">K_eff = k + c*(<span class="built_in">gamma</span>/(<span class="built_in">beta</span>*dt)) + m/(<span class="built_in">beta</span>*dt^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 循环计算每个时间步的响应</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:T<span class="number">-1</span></span><br><span class="line">    <span class="comment">% Predictor（预测）步：</span></span><br><span class="line">    x_pred = x_newmark(<span class="built_in">i</span>) + dt*v_newmark(<span class="built_in">i</span>) + dt^<span class="number">2</span>/<span class="number">2</span>*(<span class="number">1</span><span class="number">-2</span>*<span class="built_in">beta</span>)*a_newmark(<span class="built_in">i</span>);</span><br><span class="line">    v_pred = v_newmark(<span class="built_in">i</span>) + dt*(<span class="number">1</span>-<span class="built_in">gamma</span>)*a_newmark(<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算有效荷载（相当于“残差”）</span></span><br><span class="line">    R_eff = F_t(<span class="built_in">i</span>+<span class="number">1</span>) - k*x_pred - c*v_pred;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算位移修正量 Δx</span></span><br><span class="line">    delta_x = R_eff / K_eff;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 更新响应：位移、速度、加速度</span></span><br><span class="line">    x_newmark(<span class="built_in">i</span>+<span class="number">1</span>) = x_pred + delta_x;</span><br><span class="line">    v_newmark(<span class="built_in">i</span>+<span class="number">1</span>) = v_pred + <span class="built_in">gamma</span>/(<span class="built_in">beta</span>*dt)*delta_x;</span><br><span class="line">    a_newmark(<span class="built_in">i</span>+<span class="number">1</span>) = delta_x/(<span class="built_in">beta</span>*dt^<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘图比较两种方法的结果</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(time, x_freq, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;频域方法得到的相对位移时程曲线&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间 (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;位移 (mm)&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(time, x_newmark, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Newmark-β 方法得到的相对位移时程曲线&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间 (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;位移 (mm)&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">saveas(gcf, <span class="string">&#x27;时域与频域方法所得相对位移时程曲线对比.png&#x27;</span>);</span><br></pre></td></tr></table></figure></p><p>时域与频域方法所得相对位移时程曲线对比：<br><img src="/2025/02/01%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/时域与频域方法所得相对位移时程曲线对比.png" alt="时域与频域方法所得相对位移时程曲线对比图"></p>]]></content>
      
      
      <categories>
          
          <category> 力学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构动力学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构动力响应求解的数值方法</title>
      <link href="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/"/>
      <url>/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍结构动力学中结构响应求解的数值方法：杜哈梅积分、中心差分法和NewMark-β法，并利用python实现。对于matlab版本，将python代码直接扔给AI，应该不难得到，故此处不再给出。</p><ul><li><a href="./02结构动力学响应求解数值方法/ElCentro.txt">地震波时程文件</a>，单位为重力加速度g。</li></ul><h1 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h1><h2 id="杜哈梅积分"><a href="#杜哈梅积分" class="headerlink" title="杜哈梅积分"></a>杜哈梅积分</h2><p><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/杜哈梅积分原理1.jpg" alt="杜哈梅积分原理1"><br><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/杜哈梅积分原理2.jpg" alt="杜哈梅积分原理2"></p><h2 id="中心差分法"><a href="#中心差分法" class="headerlink" title="中心差分法"></a>中心差分法</h2><p><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/中心差分法原理2.jpg" alt="中心差分法原理1"><br><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/中心差分法原理1.jpg" alt="中心差分法原理2"></p><h2 id="NewMark-β法"><a href="#NewMark-β法" class="headerlink" title="NewMark-β法"></a>NewMark-β法</h2><p><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/newmark法原理1.jpg" alt="NewMark-β法1"><br><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/newmark法原理2.jpg" alt="NewMark-β法2"></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/八层框架例题.jpg" alt="八层框架例题"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### README ####</span></span><br><span class="line"><span class="comment"># 杜哈梅积分、中心差分法和Newmark-β法的python实现。</span></span><br><span class="line"><span class="comment"># 采用国际单位制（N、t、mm、s...）</span></span><br><span class="line"></span><br><span class="line">mode= <span class="built_in">input</span>(<span class="string">&quot;请输入选择的数值方法：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> eig</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构参数</span></span><br><span class="line"><span class="comment"># 质量矩阵</span></span><br><span class="line">M = np.diag([<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">110</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刚度矩阵</span></span><br><span class="line">k = np.array([<span class="number">300</span>,<span class="number">260</span>,<span class="number">260</span>,<span class="number">260</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>])*<span class="number">1e3</span></span><br><span class="line">K = np.zeros((<span class="built_in">len</span>(k),<span class="built_in">len</span>(k)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(k)-<span class="number">1</span>):</span><br><span class="line">    K[i,i] = k[i]+k[i+<span class="number">1</span>]</span><br><span class="line">    K[i+<span class="number">1</span>,i] = -k[i+<span class="number">1</span>]</span><br><span class="line">    K[i,i+<span class="number">1</span>] = -k[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">K[<span class="built_in">len</span>(k)-<span class="number">1</span>,<span class="built_in">len</span>(k)-<span class="number">1</span>] = k[<span class="built_in">len</span>(k) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻尼矩阵</span></span><br><span class="line">a0 = <span class="number">0.6296</span></span><br><span class="line">a1 = <span class="number">0.003075</span></span><br><span class="line">C = a0*M + a1*K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 地震动时程曲线</span></span><br><span class="line">time_step = <span class="number">0.005</span></span><br><span class="line">file_path = <span class="string">&#x27;ElCentro.txt&#x27;</span></span><br><span class="line">ground_acc = np.loadtxt(file_path)</span><br><span class="line">ground_acc = ground_acc*<span class="number">9.8</span>*<span class="number">1e3</span></span><br><span class="line">time = np.arange(<span class="built_in">len</span>(ground_acc))*time_step</span><br><span class="line">x0 = <span class="number">0</span></span><br><span class="line">v0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;Duhamel&quot;</span>:</span><br><span class="line">    <span class="comment">#### 采用杜哈梅积分 ####</span></span><br><span class="line">    <span class="comment"># 由于杜哈梅积分只适用于单自由度，这里先利用振型分解法将位移解耦，计算每个振型的响应时程，再叠加。</span></span><br><span class="line">    <span class="comment"># 因为python计算的特征值并没有按大小排序，而matlab是排序了的。</span></span><br><span class="line">    eigenvalues, eigenvectors = eig(K, M)</span><br><span class="line">    sorted_indices = np.argsort(np.real(eigenvalues))</span><br><span class="line">    sorted_eigenvalues = eigenvalues[sorted_indices]</span><br><span class="line">    sorted_eigenvectors = eigenvectors[:, sorted_indices]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化响应数组</span></span><br><span class="line">    num_modes = <span class="built_in">len</span>(sorted_eigenvalues)</span><br><span class="line">    response = np.zeros(<span class="built_in">len</span>(ground_acc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 逐个振型进行计算并叠加响应</span></span><br><span class="line">    <span class="keyword">for</span> mode_idx <span class="keyword">in</span> <span class="built_in">range</span>(num_modes):</span><br><span class="line">        mode = np.real(sorted_eigenvectors[:, mode_idx])  </span><br><span class="line">        mode = mode / mode[-<span class="number">1</span>]  <span class="comment"># 规范化处理：顶层振型位移为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算该振型的广义质量、刚度和阻尼矩阵</span></span><br><span class="line">        M1 = mode @ M @ mode</span><br><span class="line">        K1 = mode @ K @ mode</span><br><span class="line">        C1 = mode @ C @ mode</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算该振型的固有频率、阻尼比和阻尼频率</span></span><br><span class="line">        w1 = np.sqrt(K1 / M1)</span><br><span class="line">        s1 = C1 / (<span class="number">2</span> * M1 * w1)</span><br><span class="line">        wd1 = np.sqrt(<span class="number">1</span> - s1**<span class="number">2</span>) * w1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 杜哈梅积分计算响应</span></span><br><span class="line">        x_mode = np.zeros(<span class="built_in">len</span>(ground_acc))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ground_acc)):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">                p1 = -mode @ M @ np.ones(<span class="built_in">len</span>(k)) * ground_acc[j]</span><br><span class="line">                temp += np.exp(-s1 * w1 * (i - j) * time_step) * np.sin(wd1 * (i - j) * time_step) * p1 *time_step/ (M1 * wd1)</span><br><span class="line">            x_mode[i] = temp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将该振型的响应加到总响应中。能这么做的原因是因为所有振型中顶层的位移都是1，故直接将振型响应时程直接相加即可。</span></span><br><span class="line">        <span class="comment"># 根据这一原理，我们可以直接求出任一层的相对位移时程曲线。</span></span><br><span class="line">        response += x_mode</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制顶层位移随时间变化曲线</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(np.concatenate((time, [<span class="built_in">len</span>(k) * time_step])), np.concatenate((np.array([<span class="number">0</span>]), response)))</span><br><span class="line">    plt.xlabel(<span class="string">r&quot;$\it&#123;t&#125; (s)$&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">r&quot;$\it&#123;x&#125; (mm)$&quot;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;顶层位移计算结果.png&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;CentralDifference&quot;</span>:</span><br><span class="line">    <span class="comment">#### 中心差分法 ####</span></span><br><span class="line">    C_acc = np.zeros((<span class="built_in">len</span>(k), <span class="built_in">len</span>(time)))  </span><br><span class="line">    C_v = np.zeros((<span class="built_in">len</span>(k), <span class="built_in">len</span>(time)))   </span><br><span class="line">    C_x = np.zeros((<span class="built_in">len</span>(k), <span class="built_in">len</span>(time)))    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始位移、速度</span></span><br><span class="line">    C_x[:, <span class="number">0</span>] = x0  </span><br><span class="line">    C_v[:, <span class="number">0</span>] = v0  </span><br><span class="line"></span><br><span class="line">    C_acc[:, <span class="number">0</span>] = np.linalg.inv(M)@(-M @ np.ones(<span class="built_in">len</span>(k)) * ground_acc[<span class="number">0</span>] -C @ C_v[:, <span class="number">0</span>] - K@C_x[:, <span class="number">0</span>])</span><br><span class="line">    C_x_minus1 = C_x[:, <span class="number">0</span>] - time_step * C_v[:, <span class="number">0</span>] + C_acc[:, <span class="number">0</span>] * time_step**<span class="number">2</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    C_K = M / (time_step**<span class="number">2</span>) + C / (<span class="number">2</span> * time_step)</span><br><span class="line">    C_p_a = M / (time_step**<span class="number">2</span>) - C / (<span class="number">2</span> * time_step)</span><br><span class="line">    C_p_b = K - <span class="number">2</span> * M / (time_step**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    inv_C_K = np.linalg.inv(C_K)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(time) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            pi = -M @ np.ones(<span class="built_in">len</span>(k)) * ground_acc[i]  </span><br><span class="line">            C_pi = pi - C_p_a @ C_x_minus1 - C_p_b @ C_x[:, i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pi = -M @ np.ones(<span class="built_in">len</span>(k)) * ground_acc[i]  </span><br><span class="line">            C_pi = pi - C_p_a @ C_x[:, i - <span class="number">1</span>] - C_p_b @ C_x[:, i]</span><br><span class="line">        </span><br><span class="line">        C_x[:, i + <span class="number">1</span>] = inv_C_K @ C_pi  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            C_v[:, i] = (C_x[:, i + <span class="number">1</span>] - C_x[:, i - <span class="number">1</span>]) / (<span class="number">2</span> * time_step)  </span><br><span class="line">            C_acc[:, i] = (C_x[:, i + <span class="number">1</span>] + C_x[:, i - <span class="number">1</span>] - <span class="number">2</span> * C_x[:, i]) / (time_step**<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">    plt.figure(<span class="number">2</span>)</span><br><span class="line">    plt.plot(time, C_x[<span class="built_in">len</span>(k)-<span class="number">1</span>,:])  </span><br><span class="line">    plt.xlabel(<span class="string">r&quot;$\it&#123;t&#125; (s)$&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">r&quot;$\it&#123;x&#125; (mm)$&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;Newmark&quot;</span>:</span><br><span class="line">    <span class="comment">#### Newmark-β法 ####</span></span><br><span class="line">    N_acc = np.zeros((<span class="built_in">len</span>(k), <span class="built_in">len</span>(time)))  </span><br><span class="line">    N_v = np.zeros((<span class="built_in">len</span>(k), <span class="built_in">len</span>(time)))   </span><br><span class="line">    N_x = np.zeros((<span class="built_in">len</span>(k), <span class="built_in">len</span>(time)))    </span><br><span class="line"></span><br><span class="line">    N_x[:, <span class="number">0</span>] = x0  </span><br><span class="line">    N_v[:, <span class="number">0</span>] = v0  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选用无条件稳定的参数</span></span><br><span class="line">    beta = <span class="number">0.25</span></span><br><span class="line">    gamma = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    N_md = M + gamma * C * time_step + beta * K * time_step **<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    N_acc[:, <span class="number">0</span>] = np.linalg.inv(M) @(-M @ np.ones(<span class="built_in">len</span>(k)) * ground_acc[<span class="number">0</span>] -C @ N_v[:, <span class="number">0</span>] - K@N_x[:, <span class="number">0</span>])</span><br><span class="line">    inv_N_md = np.linalg.inv(N_md)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(time)-<span class="number">1</span>):</span><br><span class="line">        temp_v = N_v[:,i] + (<span class="number">1</span>-gamma)*N_acc[:,i]*time_step</span><br><span class="line">        temp_x = N_x[:,i] + N_v[:,i]*time_step +(<span class="number">0.5</span> - beta)*N_acc[:,i]*time_step**<span class="number">2</span></span><br><span class="line">        N_acc[:,i+<span class="number">1</span>] = inv_N_md @ (-M @ np.ones(<span class="built_in">len</span>(k)) * ground_acc[i+<span class="number">1</span>] -C @ temp_v - K@temp_x)</span><br><span class="line">        N_v[:,i+<span class="number">1</span>] = temp_v + gamma* N_acc[:,i+<span class="number">1</span>]*time_step</span><br><span class="line">        N_x[:,i+<span class="number">1</span>] = temp_x + beta * N_acc[:,i+<span class="number">1</span>] *time_step**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    plt.figure(<span class="number">3</span>)</span><br><span class="line">    plt.plot(time, N_x[<span class="built_in">len</span>(k)-<span class="number">1</span>,:])  <span class="comment"># 绘制顶层位移随时间变化</span></span><br><span class="line">    plt.xlabel(<span class="string">r&quot;$\it&#123;t&#125; (s)$&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">r&quot;$\it&#123;x&#125; (mm)$&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于杜哈梅积分利python实现起来非常耗时，所以此处也给出其matlab版本。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line">% 结构参数</span><br><span class="line">M = diag([120, 120, 120, 120, 120, 120, 120, 110]);  % 质量矩阵</span><br><span class="line">k = [300, 260, 260, 260, 200, 200, 200, 200] * 10^3;  % 刚度矩阵</span><br><span class="line">K = zeros(length(k), length(k));  % 初始化刚度矩阵</span><br><span class="line"></span><br><span class="line">% 刚度矩阵</span><br><span class="line">for i = 1:length(k)-1</span><br><span class="line">    K(i, i) = k(i) + k(i+1);</span><br><span class="line">    K(i+1, i) = -k(i+1);</span><br><span class="line">    K(i, i+1) = -k(i+1);</span><br><span class="line">end</span><br><span class="line">K(end, end) = k(end);  </span><br><span class="line"></span><br><span class="line">% 阻尼矩阵</span><br><span class="line">a0 = 0.6296;</span><br><span class="line">a1 = 0.003075;</span><br><span class="line">C = a0 * M + a1 * K;  </span><br><span class="line"></span><br><span class="line">% 地震动时程曲线</span><br><span class="line">time_step = 0.005;</span><br><span class="line">ground_acc = load(&#x27;ElCentro.txt&#x27;);  % 读取地震加速度数据</span><br><span class="line">ground_acc = ground_acc * 9.8 * 10^3;  % 转换为单位为 mm/s^2 的地震加速度</span><br><span class="line">time = (0:length(ground_acc)-1) * time_step;  </span><br><span class="line"></span><br><span class="line">% 计算特征值和特征向量</span><br><span class="line">[eigenvectors, eigenvalues] = eig(K, M);</span><br><span class="line"></span><br><span class="line">% 初始化总响应</span><br><span class="line">num_modes = length(eigenvalues);</span><br><span class="line">response = zeros(length(ground_acc), 1);</span><br><span class="line">response_test = zeros(length(ground_acc),length(k));</span><br><span class="line"></span><br><span class="line">% 逐个振型进行计算并叠加响应</span><br><span class="line">for mode_idx = 1:num_modes</span><br><span class="line">    mode = real(eigenvectors(:, mode_idx));  % 当前振型</span><br><span class="line">    mode = mode / mode(end);  % 规范化处理：顶层振型位移为1</span><br><span class="line"></span><br><span class="line">    % 计算该振型的广义质量、刚度和阻尼矩阵</span><br><span class="line">    M1 = mode&#x27; * M * mode;</span><br><span class="line">    K1 = mode&#x27; * K * mode;</span><br><span class="line">    C1 = mode&#x27; * C * mode;</span><br><span class="line"></span><br><span class="line">    % 计算该振型的固有频率、阻尼比和阻尼频率</span><br><span class="line">    w1 = sqrt(K1 / M1);</span><br><span class="line">    s1 = C1 / (2 * M1 * w1);</span><br><span class="line">    wd1 = sqrt(1 - s1^2) * w1;</span><br><span class="line"></span><br><span class="line">    % 计算该振型的响应</span><br><span class="line">    x_mode = zeros(length(ground_acc), 1);  % 地震响应时程</span><br><span class="line">    for i = 1:length(ground_acc)</span><br><span class="line">        temp = 0;</span><br><span class="line">        for j = 1:i</span><br><span class="line">            p1 = -mode&#x27; * M * ones(length(k), 1) * ground_acc(j);</span><br><span class="line">            temp = temp + exp(-s1 * w1 * (i - j) * time_step) * sin(wd1 * (i - j) * time_step) * p1 *time_step/ (M1 * wd1);</span><br><span class="line">        end</span><br><span class="line">        x_mode(i) = temp;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    % 将该振型的响应加到总响应中</span><br><span class="line">    response = response + x_mode;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 绘制顶层位移随时间变化曲线</span><br><span class="line">figure;</span><br><span class="line">plot([time, time(end) + time_step], [0; response]);</span><br><span class="line">xlabel(&#x27;\it&#123;t&#125;\rm&#123;(s)&#125;&#x27;);</span><br><span class="line">ylabel(&#x27;\it&#123;x&#125;\rm&#123;(mm)&#125;&#x27;);</span><br><span class="line">saveas(gcf, &#x27;Duhamel_Results_matlab.png&#x27;);</span><br></pre></td></tr></table></figure></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>三种方法得到的结果如下图所示。（以顶层相对位移为例）</p><p>杜哈梅积分结果(matlab):<br><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/Duhamel_Results_matlab.png" alt="杜哈梅积分结果"><br>中心差分法结果：<br><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/CentralDifference_Results.png" alt="中心差分法结果"><br>Newmark-β法结果：<br><img src="/2025/01/02%E7%BB%93%E6%9E%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%93%8D%E5%BA%94%E6%B1%82%E8%A7%A3%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/Newmark_Results.png" alt="Newmark-β法结果"></p>]]></content>
      
      
      <categories>
          
          <category> 力学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构动力学 </tag>
            
            <tag> 数值方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>施工巡检模型及其图形化界面开发</title>
      <link href="/2025/01/01%E6%96%BD%E5%B7%A5%E5%B7%A1%E6%A3%80%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/01/01%E6%96%BD%E5%B7%A5%E5%B7%A1%E6%A3%80%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>本项目是《智能设计与建造》课程的大作业，项目地址：<a href="https://github.com/Hushuangjun/ConstructionInspectionModel">https://github.com/Hushuangjun/ConstructionInspectionModel</a></p><h1 id="智能设计与建造课程作业——施工巡检模型及其图形化界面"><a href="#智能设计与建造课程作业——施工巡检模型及其图形化界面" class="headerlink" title="智能设计与建造课程作业——施工巡检模型及其图形化界面"></a>智能设计与建造课程作业——施工巡检模型及其图形化界面</h1><p>场景需求：<br><img src="/2025/01/01%E6%96%BD%E5%B7%A5%E5%B7%A1%E6%A3%80%E6%A8%A1%E5%9E%8B/场景需求.png" alt="场景需要"></p><h2 id="模型训练及使用"><a href="#模型训练及使用" class="headerlink" title="模型训练及使用"></a>模型训练及使用</h2><p>目标检测模型采用YOLOv5，数据集采用YOLO格式，图片及相应标签存放至<code>datasets</code>文件夹下。本项目也提供了本次作业训练得到的较优权重<code>best.pt</code>。<br>模型保留了传统YOLOv5模型的训练、验证和预测的代码(见train.py、val.py和detect.py)，便于后续可加入一些新的数据集进行训练。对于权重默认采用<code>best.pt</code>，数据集格式默认为<code>data/custom_data.yaml</code>，其他默认参数取值详见源码。下面是一个较为完整的示例。</p><p><strong>环境准备：</strong><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> -r requirements.txt</span><br></pre></td></tr></table></figure><br><strong>模型训练：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train<span class="selector-class">.py</span> <span class="attr">--data</span> custom_data<span class="selector-class">.yaml</span> <span class="attr">--weights</span> best<span class="selector-class">.pt</span> <span class="attr">--img</span> <span class="number">640</span> <span class="attr">--batch-size</span> <span class="number">8</span> <span class="attr">--device</span> <span class="number">0</span> <span class="attr">--cache</span> ram <span class="attr">--epochs</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><br><strong>模型验证：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python val<span class="selector-class">.py</span> <span class="attr">--weights</span> best<span class="selector-class">.pt</span> <span class="attr">--data</span> custom_data<span class="selector-class">.yaml</span>  <span class="attr">--img</span> <span class="number">640</span></span><br></pre></td></tr></table></figure><br><strong>模型预测：</strong>（预测单张图片，视频也可，选项同YOLO）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python detect<span class="selector-class">.py</span> <span class="attr">--weights</span> best<span class="selector-class">.pt</span> <span class="attr">--data</span> custom_data<span class="selector-class">.yaml</span> <span class="attr">--source</span> ./data/images/<span class="number">21</span><span class="selector-class">.jpg</span>   </span><br></pre></td></tr></table></figure></p><p><strong>启动施工巡检模型的命令:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py --weights best.pt --data custom_data.yaml  --device <span class="number">0</span></span><br></pre></td></tr></table></figure><br>也可以直接运行<code>python main.py</code>，参数默认采用为上面这行命令。</p><p>tips:</p><ol><li>云服务器中linux系统下中文支持：<code>cp /mnt/Arial.Unicode.ttf  /root/.config/Ultralytics/</code>，也就是说需要准备相应字体，否则图形化界面中文乱码。</li></ol><h2 id="模型调用的API"><a href="#模型调用的API" class="headerlink" title="模型调用的API"></a>模型调用的API</h2><p>当中在<code>utilsbymeself</code>文件夹下存放了几个工具，主要是调用外部API实现某种功能，要想运行，需要将相应的API key改成自己的，在各公司官网上都有详尽示例，这里就不再详细赘述。</p><ol><li><a href="https://lbsyun.baidu.com/apiconsole/center">acquire_data_location.py</a>：通过调用百度地图的API实现将图片中的经纬度坐标转化成省市区街道名称等。</li><li><a href="https://console.smsbao.com/#/login?redirect=%2Findex">auto_sending_message.py</a>：通过调用短信宝的API，实现当模型发现火情的第一时间发送短信给相关负责人。</li><li><a href="https://login.bce.baidu.com/?redirect=https%3A%2F%2Fconsole.bce.baidu.com%2Fqianfan%2Foverview">llm_generate_file.py</a>：通过调用百度智能云提供的大模型实现施工巡检日志中发现问题的解决方案。</li></ol><h2 id="生成结果"><a href="#生成结果" class="headerlink" title="生成结果"></a>生成结果</h2><p>下面是施工巡检模型图形化界面。<br><img src="/2025/01/01%E6%96%BD%E5%B7%A5%E5%B7%A1%E6%A3%80%E6%A8%A1%E5%9E%8B/施工巡检模型图形化界面.jpg" alt="施工巡检模型图形化界面"><br>最后还会生成施工巡检报告。<br><img src="/2025/01/01%E6%96%BD%E5%B7%A5%E5%B7%A1%E6%A3%80%E6%A8%A1%E5%9E%8B/施工巡检日志.jpg" alt="施工巡检日志"></p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>限于水平和时间，模型肯定有诸多不足之处，还望见谅。如果新的想法，可一起交流。</p><h2 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h2><p>后期如果视频上传到B站了，附上相应的演示视频。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 大语言模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限单元法</title>
      <link href="/2024/OldBlogs/10%E6%9C%89%E9%99%90%E5%8D%95%E5%85%83%E6%B3%95/"/>
      <url>/2024/OldBlogs/10%E6%9C%89%E9%99%90%E5%8D%95%E5%85%83%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>弹性力学问题有限元分析基本步骤如下图所示。</p><p><img src="弹性力学问题有限元分析基本步骤.png" alt="弹性力学问题有限元分析基本步骤"></p><p>从上图中可以看出，分析的核心在于单元以及形函数的选取，本篇文章主要讲形函数的选取。</p><ol><li>梁单元形函数构造方法：<a href="https://bbs.co188.com/thread-10341497-1-1.html">有限单元法科普（二）——这次聊梁单元(Beam element）</a>，不过里面的例子有问题，不要看。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 有限元分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换及其应用</title>
      <link href="/2024/OldBlogs/09%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2024/OldBlogs/09%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近写智能设计与建造的作业，偶然兴起想把地震动响应(时域信号)转换成频域信号，需要用到傅里叶变换，于是就去系统学了学，做了相关笔记(手稿)，后面有兴趣还会做一些简单的项目实战一下。<br>参考资料：</p><ol><li><a href="https://www.bilibili.com/video/BV1aW4y1y7Hs/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=41769b252ab81d02e47e5775242eda15">李永乐讲傅里叶变换</a>: 只推荐前半部分，后半部分就在乱讲。</li><li><a href="https://www.bilibili.com/video/BV1Ps4y137WL/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=41769b252ab81d02e47e5775242eda15">傅里叶变换通俗解释</a>: 对于三角函数系的正交表示提了一嘴，有利于我们记忆。</li><li><a href="https://kaizhao.net/blog/fourier">从傅里叶级数到傅里叶变换：详细的数学推导</a></li><li><a href="https://www.bilibili.com/video/BV1jt411U7Bp/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=41769b252ab81d02e47e5775242eda15">傅里叶变换推导</a>: 这个视频很好地弥补了李永乐老师讲的不足的地方。</li><li><a href="https://www.yvonshong.com/2016/04/09/fft/">本篇博客封面</a>：本篇博客封面引用了该文章里的图片，内容并未详细阅读。</li></ol><h1 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h1><div class="row">    <embed src="Fouriertransform.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>本文选取的地震波文件:<a href="https://github.com/Hushuangjun/Hushuangjun.github.io/blob/theme_anzhiyu/2024/OldBlogs/09%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/acc.txt">acc.txt</a>，使用离散傅里叶变换将地震加速度时程曲线转化成频域曲线，相关代码如下：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_acc = fopen(<span class="string">&#x27;./acc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">acc_data = fscanf(file_acc,<span class="string">&#x27;%f&#x27;</span>,[<span class="number">1</span>,<span class="built_in">inf</span>]);</span><br><span class="line">acc_data = <span class="built_in">reshape</span>(acc_data,[],<span class="number">1</span>);</span><br><span class="line">acc_data = <span class="number">9.8</span> * acc_data;  <span class="comment">% Convert to m/s^2</span></span><br><span class="line">fclose(file_acc);</span><br><span class="line"></span><br><span class="line">rows_acc_data = <span class="built_in">size</span>(acc_data,<span class="number">1</span>);</span><br><span class="line">total_time = (rows_acc_data<span class="number">-1</span>) * <span class="number">0.01</span>;  <span class="comment">% Sample interval is 0.01s</span></span><br><span class="line">time_data = <span class="number">0</span>:<span class="number">0.01</span>:total_time;</span><br><span class="line">time_acc = [time_data&#x27;, acc_data];</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Manual DFT</span></span><br><span class="line">base_freq = <span class="number">2</span> * <span class="built_in">pi</span> / (rows_acc_data<span class="number">-1</span>);</span><br><span class="line">Freq = <span class="built_in">zeros</span>(rows_acc_data<span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:rows_acc_data<span class="number">-1</span></span><br><span class="line">    Freq(k,<span class="number">1</span>) = (k<span class="number">-1</span>) / total_time;</span><br><span class="line">    temp_freq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">1</span>:rows_acc_data<span class="number">-1</span></span><br><span class="line">        temp_freq = temp_freq + time_acc(n,<span class="number">2</span>) * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span> * (n<span class="number">-1</span>) * (k<span class="number">-1</span>) * <span class="number">2</span> * <span class="built_in">pi</span> / (rows_acc_data<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Freq(k,<span class="number">2</span>) = <span class="built_in">abs</span>(temp_freq);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">n_f = <span class="built_in">floor</span>((rows_acc_data<span class="number">-1</span>)/<span class="number">2</span>);  <span class="comment">% Nyquist frequency index</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% MATLAB Built-in FFT</span></span><br><span class="line">Fs = <span class="number">100</span>;  <span class="comment">% Sampling frequency (1/0.01)</span></span><br><span class="line">L = rows_acc_data<span class="number">-1</span>;</span><br><span class="line">Y = fft(acc_data(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>));</span><br><span class="line">P2 = <span class="built_in">abs</span>(Y);</span><br><span class="line">P1 = P2(<span class="number">1</span>:<span class="built_in">floor</span>(L/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">P1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>) = <span class="number">2</span>*P1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>);</span><br><span class="line">f = Fs * (<span class="number">0</span>:(L/<span class="number">2</span>))/L;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot comparison</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% Manual DFT plot</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(Freq(<span class="number">1</span>:n_f,<span class="number">1</span>), Freq(<span class="number">1</span>:n_f,<span class="number">2</span>), <span class="string">&#x27;b-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">title(<span class="string">&quot;Manual DFT&quot;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;Frequency (Hz)&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;Magnitude&quot;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% MATLAB FFT plot</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, P1, <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">title(<span class="string">&quot;MATLAB FFT&quot;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;Frequency (Hz)&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;Magnitude&quot;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure></p><p>最后结果也是和matlab中fft计算结果吻合较好。<br>加速度时程曲线：<br><img src="/2024/OldBlogs/09%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/time_acc.png" alt="加速度时程曲线"></p><p>利用DFT公式计算结果与MATLAB中FFT计算结果对比：<br><img src="/2024/OldBlogs/09%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/DFT与FFT.png" alt="DFT与FFT"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语音标与自然拼读</title>
      <link href="/2024/OldBlogs/02%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/OldBlogs/02%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>最近在给小学六年级的朋友做英语辅导。说起音标，我也是大学才开始逐渐了解的，有了自己的一点见解，但不多，借这个机会系统学学！</p><h1 id="音标"><a href="#音标" class="headerlink" title="音标"></a>音标</h1><h2 id="学好音标的重要性"><a href="#学好音标的重要性" class="headerlink" title="学好音标的重要性"></a>学好音标的重要性</h2><p>发音是学英语十分关键的一步，发音不正确就听不准、读不好，更谈不上用英语交流。学习英语听、说、读、写四种能力不可偏废，而正确的发音是基础，音标的学习更是基础的基础。</p><h2 id="英语字母"><a href="#英语字母" class="headerlink" title="英语字母"></a>英语字母</h2><p>英语有26个字母：<br>A a, B b, C c, D d, E e, F f, G g, H h, I i, J j, K k, L l, M m, N n, O o, P p, Q q, R r, S s, T t, U u, V v, W w, X x, Y y, Z z<br>元音字母为：A a, E e, I i, O o, U u，其余为辅音字母。<br>（有没有想过为啥叫元音字母呀？因为这些字母一般发元音。同理，辅音字母一般发辅音，于是有同学问了，为啥是一般呢？因为也有例外呀，英语学习中充斥着太多的例外了，先掌握一般规律，再记特例。）</p><h2 id="音标的分类"><a href="#音标的分类" class="headerlink" title="音标的分类"></a>音标的分类</h2><ol><li>英语国际英标有48个，其中20元音，28个辅音。</li><li>元音可分为长元音（5个）、短元音（7个）和双元音（8个）。</li><li>辅音主要有清辅音、浊辅音、鼻音等。</li></ol><p>元音是指发音时气流通过口腔或鼻腔时，不受任何阻碍，同时声带振动。英语中的元音共有20个。<br>辅音是指发音时，气流从肺部压出来后，通过口腔或鼻腔时受到各发音器官的阻碍，如受到唇、齿、舌、咽喉等的阻碍而形成的音。英语中的辅音音素按发音时声带是否振动可以分为11个清辅音和17个浊辅音。<br>清辅音发音时声带不振动，浊辅音发音时声带振动。<br>【对于初学者先学会读很重要，后期再慢慢修正】<br>长元音：/a:/, /ɔ:/, /ɜ:/, /i:/, /u:/<br>短元音：/ʌ/, /ɒ/, /ə/, /i/, /ʊ/, /e/, /ae/<br>双元音：/ei/, /ai/, /ɔi/, /iə/, /εə/, /ʊə/, /əu/, /au/<br>清辅音：/p/, /t/, /k/, /f/, /θ/, /s/, /ʃ/, /tʃ/, /ts/, /tr/, /h/<br>浊辅音：/b/, /d/, /g/, /v/, /ð/, /z/, /ʒ/, /dʒ/, /dz/, /dr/, /r/<br>鼻音： /m/, /n/, /ŋ/<br>其它：/j/, /w/, /l/</p><h2 id="音标表"><a href="#音标表" class="headerlink" title="音标表"></a>音标表</h2><p>所谓浊音（即浊辅音），就是声带要振动的音；清音（即清辅音）就是发出了但声带却不振动的音<br>所有的元音都是浊音，声带都要振动。</p><h3 id="一-元音音素："><a href="#一-元音音素：" class="headerlink" title="一.元音音素："></a>一.元音音素：</h3><p>1./I:/    【衣~】<br>2./I/     【衣】<br>3./e/     【哎】<br>4./æ/     【哎】<br>5./ɜ:/    【额~】<br>6./ə/     【额】<br>7./∧/    【啊】<br>8./a:/    【啊~】<br>9./ɒ/     【噢】<br>10./כ:/     【噢~】<br>11./ʊ/     【乌】<br>12./u:/    【乌~】<br>13./eI/    【唉衣，即A的发音 】<br>14./aI/    【唉】<br>15./כI/    【噢衣】<br>16./əu/    【额乌，即O的发音】<br>17./au/    【傲】<br>18./Iə/    【衣饿】<br>19./eə/    【哎饿】<br>20./ʊə/    【乌饿】</p><h3 id="二-辅音音素："><a href="#二-辅音音素：" class="headerlink" title="二.辅音音素："></a>二.辅音音素：</h3><p>1./p/     【泼，清音】<br>2./b/     【波，浊音】<br>3./t/     【特，清音】<br>4./d/     【的，浊音】<br>5./k/     【科，清音】<br>6./g/     【各，浊音】<br>7./f/     【福，清音】<br>8./v/     【乌，浊音】<br>9./s/     【丝，清音】<br>10./z/     【丝，/s/的浊音】<br>11./θ/     【丝，牙齿咬住舌头的清音】<br>12./δ/     【资，牙齿咬住舌头的浊音】<br>13./∫/    【诗，清音】<br>14./Ʒ/     【日，浊音】<br>15./h/     【喝，清音】<br>16./r/     【若，浊音】<br>17./t∫/   【吃，清音】<br>18./dƷ/    【知，浊音】<br>19./tr/    【吹，清音】<br>20./dr/    【捉，浊音】<br>21./ts/    【次，清音】<br>22./dz/    【资，浊音】<br>23./m/     【母】<br>24./n/     【呢】<br>25./ŋ/     【嗯】<br>26./l/     【了，浊音】<br>27./w/     【我，浊音】<br>28./j/     【耶，浊音】</p><h1 id="音节"><a href="#音节" class="headerlink" title="音节"></a>音节</h1><h2 id="音节概念"><a href="#音节概念" class="headerlink" title="音节概念"></a>音节概念</h2><p>音节是以元音音素为主体、以辅音音素为分界线的的发音单位，任何单词的读音，都可以分解为一个个音节朗读。<br>（如果此处不好理解，可以从汉语角度出发解释。在汉语中，通常一个字代表一个音节，音节一般由声母（可理解为元音）加韵母（可理解为辅音）组成，例如“爸bà”。）<br>与汉语不同的是，英语中一个单词可能有多个音节，单词按照音节数量的多少可分为单音节单词、双音节单词和多音节单词。<br><strong>单音节单词</strong>：有且只有一个元音音素的单词；<br>my  he  book  raise  I  so  two   desk  friend  strong  stratch  quiet<br><strong>双音节单词</strong>：含有两个元音音素的单词；<br>rhythm city  ruler  giraffe   fourteen<br><strong>多音节单词</strong>：含有三个及其以上元音音素的单词。<br>elephant  eraser  January  usually  congratulations</p><p>从上面这些单词音节划分来看，<strong>元音音素不等于元音字母（比如quiet中u发/w/的音），辅音音素不等于辅音字母（比如rhythm中thm发），而且有些元音字母不发音（比如giraffe中的“e”）</strong>，所以单从元音字母、辅音字母来划分音节并不怎么可靠（当然，并不是行不通，只不过需要记得东西较多），所以推荐看音标划分。那么看见一个音标如何划分呢？<br>（故后面所讲元音是指元音音素，辅音是指辅音音素）</p><h2 id="音节的划分"><a href="#音节的划分" class="headerlink" title="音节的划分"></a>音节的划分</h2><p>决定一个单词音节数量的关键是：音标里元音音素的数量。单词里有几个元音音标就有几个音节。不过，还有一个特殊情况：英语中的某些辅音音素，如/m/、/n/、/ŋ/、/l/，它们与辅音音素结合时也能构成音节，这样的音节称为“成音节”。<br>根据单词音标划分：</p><ol><li>找元音；</li><li>数辅音；</li><li>一靠后，二分手，多个中间偏左右。</li></ol><p>举个例子：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Word</th><th style="text-align:center">Pronunciation</th></tr></thead><tbody><tr><td style="text-align:center">open</td><td style="text-align:center">[ˈəʊpən]</td></tr><tr><td style="text-align:center">paper</td><td style="text-align:center">[ˈpeɪpə(r)]</td></tr><tr><td style="text-align:center">sofa</td><td style="text-align:center">[ˈsəʊfə]</td></tr><tr><td style="text-align:center">computer</td><td style="text-align:center">[kəmˈpjuːtə(r)]</td></tr><tr><td style="text-align:center">pencil</td><td style="text-align:center">[‘pens(ə)l]</td></tr><tr><td style="text-align:center">beautiful</td><td style="text-align:center">[ˈbjuːtɪf(ə)l]</td></tr></tbody></table></div><p>如果从单词直接划分音节，然后根据元音字母在单词中的读音拼读音节，完成单词的拼读，这一过程被老师和专业书籍称为“自然拼读法”。这需要引入开音节、闭音节以及各种规则，较为繁琐，其实常见的单词我们都会读，不常见的单词我们习惯看音标，这样只需根据音标来划分就好了，不用那么麻烦。<br>当然，作为了解，后续也会补充“自然拼读法”的知识，这里暂且根据单词音标来划分。于是又有一个问题出来了，单个音节如何发音呢？</p><h2 id="音节的拼读"><a href="#音节的拼读" class="headerlink" title="音节的拼读"></a>音节的拼读</h2><p>对于一个音节，其拼读方法总结为如下几点</p><ol><li>元音+辅音：各读各音。例如：/i:/—/t/，/i:t/（it）；</li><li>辅音+元音：两者拼读。例如：/b/—/i:/，/bi:/（B）；</li><li>辅音+元音+辅音：第一个辅音先跟元音拼读，然后再与第二个辅音连读。例如：/bi/—/t/，/bit/（bit）；</li><li>辅音+辅音+元音+辅音(可有无可无)：第二个辅音先跟元音拼读，然后再与第一个辅音连读，有第三个辅音的话，继续连读。例如：/b/—/læ/—/k/，/blæk/（black）；</li></ol><h1 id="音标的浊化"><a href="#音标的浊化" class="headerlink" title="音标的浊化"></a>音标的浊化</h1><p>浊化是指声带不振动的清辅音转化为声带振动的浊辅音的现象，浊化现象对于英语母语者而言是没有这一概念的，只是为了方便我们把英语作为第二语言进行更好地学习而总结的发音规律。以辅音“s”为例，其后辅音浊化有以下四种：</p><ol><li>/sk/ + 元音 ——&gt; /sg/ + 元音<ul><li>sky /skaI/ 天空</li></ul></li><li>/st/ + 元音 ——&gt; /sd/ + 元音<ul><li>study /st∧di/ 学习</li></ul></li><li>/sp/ + 元音 ——&gt; /sb/ + 元音<ul><li>sport /spכ:t/ 运动</li></ul></li><li>/str/ + 元音 ——&gt; /sdr/ + 元音<ul><li>street /stri:t/ 街道</li></ul></li></ol><p><strong>浊化的条件：</strong></p><ol><li>该清辅音后面一定要有元音。</li><li>这个元音必须是单词的重音所在。</li></ol><p>比如excuse ([iksˈkju:z]) ，ex念/iks/，后面跟的音节是/kju:/，也就是说中间没有元音，不需要要浊化。而basket ([ˈbɑ:skit]) 不浊化就是第二个规则的典型，/skit/的元音是处在第二个音节上，而重音不在这里，所以也不需要浊化。</p>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音标 </tag>
            
            <tag> 单词拼读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研绘图</title>
      <link href="/2024/OldBlogs/02%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/"/>
      <url>/2024/OldBlogs/02%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>最近写本科毕业论文，需要用到绘图，总结方法如下，持续补充！</p><h1 id="MATLAB绘图"><a href="#MATLAB绘图" class="headerlink" title="MATLAB绘图"></a>MATLAB绘图</h1><p>具体可参见matlab帮助文档，现查现用，比较方便，同时结合ChatGPT等工具，直接无敌！</p><iframe src="//player.bilibili.com/player.html?aid=204192539&bvid=BV13h411y7TK&cid=299101816&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="PPT绘图"><a href="#PPT绘图" class="headerlink" title="PPT绘图"></a>PPT绘图</h1><h1 id="Visio绘图"><a href="#Visio绘图" class="headerlink" title="Visio绘图"></a>Visio绘图</h1><h1 id="Origin绘图"><a href="#Origin绘图" class="headerlink" title="Origin绘图"></a>Origin绘图</h1>]]></content>
      
      
      <categories>
          
          <category> 科研工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高搜索效率的小技巧</title>
      <link href="/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><p>从搜索效率来看，排序如下：<br><strong>谷歌 &gt; 公众号 &gt; 短视频 &gt; 百度</strong>；</p><p>对于本专业，由于经常需要搜索中文，这时候许多公众号文章质量比较高，但百度是搜索不到的，这时候推荐使用<strong>搜狗引擎</strong>，可以直接搜索微信公众号文章！</p><h1 id="基础搜索语法"><a href="#基础搜索语法" class="headerlink" title="基础搜索语法"></a>基础搜索语法</h1><p>以Google为例：</p><h2 id="“-“限定关键词"><a href="#“-“限定关键词" class="headerlink" title="“ “限定关键词"></a>“ “限定关键词</h2><p>如下图所示：<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/分号限定关键词.jpg" alt="&quot;&quot;限定关键词"></p><p>不然，得到的结果非常之多，还有可能被热门人物所覆盖，得不到想要的结果！</p><h2 id="intitle限定标题关键词"><a href="#intitle限定标题关键词" class="headerlink" title="intitle限定标题关键词"></a>intitle限定标题关键词</h2><p>如下图所示：(注意，必须是英文冒号<code>:</code>，下同)<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/intitle限定标题.jpg" alt="intitle限定标题"></p><p>上述得到的结果只是一个标题里包含上述关键词，并不一定连续，如果改为：intitle:”华为遥遥领先”，则标题中关键词也必须是连续的。如下图：<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/intitle加分号一起限定.jpg" alt="intitle+&quot;&quot;同时限定"></p><h2 id="allintitle限定标题多个关键词"><a href="#allintitle限定标题多个关键词" class="headerlink" title="allintitle限定标题多个关键词"></a>allintitle限定标题多个关键词</h2><p>如果想要限定标题多个关键词，就可以使用allintitle.<strong>各关键词之间用空格分隔</strong>！<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/allintitle限定标题多个关键词.jpg" alt="allintitle限定标题多个关键词"></p><h2 id="intext限定内容关键词"><a href="#intext限定内容关键词" class="headerlink" title="intext限定内容关键词"></a>intext限定内容关键词</h2><p>本质与上面intitle无异，只是限定内容关键词，故不过多赘述！</p><h2 id="intitle和intext联合使用"><a href="#intitle和intext联合使用" class="headerlink" title="intitle和intext联合使用"></a>intitle和intext联合使用</h2><p>如下图所示：<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/intitle和intext联合使用.jpg" alt="intitle和intext联合使用"></p><h2 id="inurl限定网址关键词"><a href="#inurl限定网址关键词" class="headerlink" title="inurl限定网址关键词"></a>inurl限定网址关键词</h2><p>如下图所示：<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/inurl限定网址.jpg" alt="inurl限定网址关键词"></p><h2 id="site限定网址来源"><a href="#site限定网址来源" class="headerlink" title="site限定网址来源"></a>site限定网址来源</h2><p>如下图所示：<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/site限定网址来源.jpg" alt="site限定网址来源"></p><h2 id="imagesize限定图片尺寸"><a href="#imagesize限定图片尺寸" class="headerlink" title="imagesize限定图片尺寸"></a>imagesize限定图片尺寸</h2><p>特别要注意，书写时，例如: Jason Zhang imagesize:1080x1080.中间那个<code>x</code>不是乘号，而是英文字母<code>x</code>!<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/imagesize限定图片尺寸.jpg" alt="imagesize限定图片尺寸"></p><h2 id="filetype限定文件格式"><a href="#filetype限定文件格式" class="headerlink" title="filetype限定文件格式"></a>filetype限定文件格式</h2><p>在找书的过程中十分好用！例如：<br><img src="//husj0711.top/2024/OldBlogs/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/filetype限定文件格式.jpg" alt="filetype限定文件格式"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/tiN6T1LewmQ?si=jVCcDc6gzv8VZM9k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 实用小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 检索信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本科毕业论文进展记录</title>
      <link href="/2024/OldBlogs/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%9B%E5%B1%95/"/>
      <url>/2024/OldBlogs/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%9B%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>记录毕业论文进展，监督自己，共勉之！</p></div><h3 id="2024-1-17记录"><a href="#2024-1-17记录" class="headerlink" title="2024-1-17记录"></a>2024-1-17记录</h3><p>今天老师开了一次组会，大致讲了一下接下来安排，时间要抓紧啦。自从上次卡在自己给自己设的坑那里，就没动过了。最近一个月都在忙复习，主要是钢结构设计。只能说有舍有得吧，感觉经过钢结构设计，自己能力又得到进一步提升。随着期末接近尾声，还差最后一门高英，加油！</p><ul><li>在系统中上传了一次周进展；</li><li>完成了英文文献摘要部分的翻译；</li></ul><h3 id="2024-1-18记录："><a href="#2024-1-18记录：" class="headerlink" title="2024-1-18记录："></a>2024-1-18记录：</h3><p>Done：</p><ul><li>完成了英文文献引言部分的翻译。PS: 果然，老外写的句子跟咱们中国人写的句子不太一样，感觉说话断断续续的，难翻的要命😔。</li></ul><p>估计要断更一两天了，明天就要考最后一门啦，考完就要收拾东西回家了，一天都得奔走在路上，加油加油！</p><h3 id="2024-1-19记录："><a href="#2024-1-19记录：" class="headerlink" title="2024-1-19记录："></a>2024-1-19记录：</h3><p>考完最后一门了，回家回家！<br>Done:</p><ul><li>文献翻译到有限元分析了，今晚再努把力，明天祈祷火车上能把翻译工作推进一下，或者看看CST方法，得加快进度了。</li></ul><h3 id="2024-1-21记录："><a href="#2024-1-21记录：" class="headerlink" title="2024-1-21记录："></a>2024-1-21记录：</h3><p>今天终于回到家了！！！<br>在火车上复习了CST方法，顺便把要翻译的文献通了一遍。<br>Done:</p><ul><li>完成了文献翻译。</li></ul><h3 id="2024-1-22记录："><a href="#2024-1-22记录：" class="headerlink" title="2024-1-22记录："></a>2024-1-22记录：</h3><p>Done: </p><ul><li>今天回顾了穿孔钢梁的一些设计方法！！！</li></ul><p>Plan:</p><ul><li>明天一定要验算以下模型了，不能再停滞不前了！！！</li></ul><h3 id="2024-1-23记录："><a href="#2024-1-23记录：" class="headerlink" title="2024-1-23记录："></a>2024-1-23记录：</h3><p>Done:</p><ul><li>弄清楚了ANSYS WB中如何将实体单元转化为壳单元。明天就可以开始验算论文内容了！！！</li></ul><h3 id="2024-1-24记录："><a href="#2024-1-24记录：" class="headerlink" title="2024-1-24记录："></a>2024-1-24记录：</h3><p>Done:</p><ul><li>学会了穿孔钢梁运用shell 181建模；</li><li>上传了一次周进展；</li></ul><h3 id="2024-1-25记录："><a href="#2024-1-25记录：" class="headerlink" title="2024-1-25记录："></a>2024-1-25记录：</h3><p>Done:</p><ul><li>今天完成了特征值屈曲分析，终于可以试验设计了！！！</li></ul><p>明天得争取开始用C语言编程了！！！</p><h3 id="2024-1-29记录："><a href="#2024-1-29记录：" class="headerlink" title="2024-1-29记录："></a>2024-1-29记录：</h3><p>Done:</p><ul><li>完成了C语言编程生成CAD命令流，现在只需要更改文件里的参数，就可以自动生成相应的三维孔洞形状CAD命令流啦。</li><li>借助上述命令流完成一个孔洞形状建模，并导入ANSYS WB中，惊奇地发现，每次只要更改导入的孔洞形状文件(.sat)，就可以生成对应的穿孔钢梁几何模型啦，太酷啦！！！</li><li>初步采用拉丁超立方采样，多项式拟合得到响应面！！！因为现在自己只会Design Expert软件，先用多项式拟合看看，精度不行增加样本点即可。等后面有空了再考虑Kriging等方法来拟合！！！</li></ul><h3 id="2024-2-1记录："><a href="#2024-2-1记录：" class="headerlink" title="2024-2-1记录："></a>2024-2-1记录：</h3><p>Done:</p><ul><li>完成了15组（有两组存在尺寸干涉）试验仿真，然后代入design expert软件中，进行多项式拟合；结果还不错，各项指标还可以，并验证了两者，误差还行。但对于ANSYS WB跑出来的结果，我是有点疑问的，因为感觉孔开的越大，临界屈曲荷载越大，也有可能是自己还未了解特征值屈曲分析，下阶段可以了解了解！！！</li><li>上传了一次周进展；</li></ul><h3 id="2024-2-7记录："><a href="#2024-2-7记录：" class="headerlink" title="2024-2-7记录："></a>2024-2-7记录：</h3><p>快过年啦，这些天忙于其他事，毕业论文小小耽搁一下嘿嘿🤭！</p><h3 id="2024-2-22记录："><a href="#2024-2-22记录：" class="headerlink" title="2024-2-22记录："></a>2024-2-22记录：</h3><p>过完年啦，明天就要启程返校了，今天又弄了弄第一部分绪论，自我感觉条例又清晰了些，希望吧哈哈！<br>明后天火车上希望能把家里学的复习一下啊，过年真的是一点没动，后面一定要改过自新，加油搞钱！<br>启程返航！</p><h3 id="2024-3-1记录："><a href="#2024-3-1记录：" class="headerlink" title="2024-3-1记录："></a>2024-3-1记录：</h3><p>Done:</p><ul><li>学习了最优拉丁超立方抽样，然后跑出来数据，拿去拟合，得到了多项式响应面模型。</li></ul><p>困惑点：</p><ol><li>我用这个模型预测，感觉效果还是不太好，是否需要新增加样本？这又是个未知数，我想先进行多目标优化之后再进行针对性的选点。</li><li>现在模型孔开的越大，临界屈曲荷载越大，不符合常理啊，于是我试了几下发现了奥妙，原来实腹钢梁自重就可达到507N/m的均布荷载，感觉都快成自重控制了。于是我去掉重力加速度，果然，孔开的越大临界屈曲荷载越小，这也证实了我的猜想，下一步要把模型尺寸先改改！</li></ol><h3 id="2024-3-6记录："><a href="#2024-3-6记录：" class="headerlink" title="2024-3-6记录："></a>2024-3-6记录：</h3><p>Done:</p><ul><li>弄清楚了为啥开的孔越大，临界屈曲荷载越大了，原来ANSYS Workbench得出的乘数是以自重和施加的载荷为基数的，并不是单纯的以载荷为基数，故需要迭代求解！</li><li>于是重新对31个样本进行特征值屈曲分析，得到的结果，利用design expert进行多项式响应面拟合，得到了一个精度还算不错的函数。</li><li>学习了sobol敏感度分析原理，网上有相应的Matlab源码，稍作修改即可使用。</li></ul><p>Schedule:</p><ul><li>学习利用NSGA-Ⅱ算法进行多目标寻优；</li><li>学完多目标寻优，再复盘整个论文，看哪里可以再改进，比如开始的31个样本数有点少感觉，可以增加到40个样本数的。前面也忘记验证有限元模型的正确性了，争取能找到一篇论文复现一下！</li><li>考虑再利用kriging等其他代理模型，对比各模型精度再最终选择代理模型！</li></ul><h3 id="2024-3-17记录："><a href="#2024-3-17记录：" class="headerlink" title="2024-3-17记录："></a>2024-3-17记录：</h3><p>Done:</p><ul><li>完成了NSGA-Ⅱ的学习，并修改了网上现成代码，使之适用于本项目！</li><li>学习了kriging模型相关理论，真难啊，打算出篇博客好好讲讲！虽然我也是半吊子水平O(∩_∩)O哈哈哈</li></ul><p>下一步打算就是再验算一下kriging模型，调参数才是最难的呀！然后增加试验样本数到40吧。<br>完成上述就着手写论文啦，奥里给！</p><h3 id="2024-3-23记录："><a href="#2024-3-23记录：" class="headerlink" title="2024-3-23记录："></a>2024-3-23记录：</h3><p>Done:</p><ul><li>完成毕业论文第1-3章；</li></ul><p>下面打算学习后面一些理论知识，填充论文而已，加油！<br>明天出发去上海咯，有点兴奋哈哈！</p><h3 id="2024-4-14记录："><a href="#2024-4-14记录：" class="headerlink" title="2024-4-14记录："></a>2024-4-14记录：</h3><p>今天完成了毕业论文初稿哈哈，但是感觉结果优化并不咋好，主要一开始感觉穿孔钢梁就没啥好优化的哈哈，先就这样吧，过两天看老师反馈吧。</p><p>突然想起来，敏感度分析那里原因还没搞懂，还有BP神经网络是否需要自己用matlab或者python再写一遍(改一遍)，感觉直接用matlab工具箱的也可以，后续考虑考虑吧！</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钢结构设计作业（海大）</title>
      <link href="/2024/OldBlogs/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/2024/OldBlogs/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>需要注意的是，本文所提供的下载链接只保持三天！！！过期如有需要可在下方或者在<code>友链-&gt;留言板</code>处留言！</p></div><div class="tip warning"><p>如果pdf未显示，刷新一下即可！(●ˇ∀ˇ●)</p></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>建议：<strong>务必把上个学期卷子弄懂！</strong>    <a href="http://qny.husj0711.top/%E9%92%A2%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7.zip?e=1704990717&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:eLxXIfMn4TbthvFmpiNhptpEyr4=">点击开始下载试卷和答案</a>.</p><p>由于选择、判断没有详细解释，现把每题对应PPT分析如下：</p><details class="folding-tag" yellow><summary> 点击展开 </summary>              <div class="content">              <p><strong>选择题：</strong></p><blockquote><p>Chap 1代表第一章PPT，以此类推。Chap 4指《04-2多高层钢结构》，《04-1高层结构地震分析》会单独指出。</p></blockquote><ol><li>Chap 2; P37;</li><li>Chap 1; P9;</li><li>Chap 1; P11;</li><li>《混凝土结构中册》; P11;</li><li>Chap 4; P84;</li><li>Chap 2; P12;</li><li>Chap 3; P105;</li><li>Chap 3; P142;</li><li>Chap 3; P65;</li><li>Chap 4; P5;</li></ol><p><strong>判断题:</strong></p><ol><li>摇摆柱定义见《钢结构上册》第五章； P156; 摇摆柱上下都是铰接节点，当然不能提供抗侧力呀！</li><li>Chap 1; P19;</li><li>《04-1 高层结构地震分析》； P3;  如果不好理解，建议看《建筑结构抗震》振型分解反应谱法推导过程，相对好理解;</li><li>Chap 1; P25;</li><li>Chap 2；P11;</li><li>Chap 2; P51;</li><li>Chap 3; P77;</li><li>Chap 3; P110; 从曲线得出是跃越失稳；还不明白啥是极值点失稳、分支点失稳和跃越失稳？详见《钢结构上册》P72；</li><li>Chap 4; P7;</li><li>Chap 4; P91; </li></ol>              </div>            </details><p>最后两个大题，目前意思是<code>第三章课上小测</code>和<code>第二章加强上翼缘吊车梁强度验算</code>，先把这两个题牢牢掌握。但第三章课上小测相比去年那个题目难度下降太多，小心有坑！而且第二章吊车梁，老师说今年会出稍微难点，可能会出<code>制动梁或者制动桁架</code>。注意，不要被求解弯矩M/剪力V复杂代码吓着，考试肯定会给出内力的，重点在<code>截面特性计算</code>和<code>强度验算</code>。拿下大题及格应该不难！</p><p>下面是老师上课暗示过必考或者很可能考的内容，尽量弄懂:<br><details class="folding-tag" yellow><summary> 点击展开 </summary>              <div class="content">              <ol><li>风振系数$\beta_{z}$和阵风系数$\beta_{gz}$适用对象；<br>风振系数是计算主体结构的，阵风系数是计算维护结构的。</li><li>高层建筑在水平荷载作用下位移曲线呈剪切型和弯曲型，主要由于啥变形造成的？<br>剪切型是由于梁、柱弯曲变形造成的，弯曲型主要是柱轴向变形造成的。</li><li>抗震设计的<code>三水准两阶段</code><br>详见第四章PPT34、35页。</li><li>S1-S5级截面的含义，在轻型门式刚架刚架梁、柱翼缘和腹板的截面分类属于哪一类？<br>截面分类请参考《钢结构设计标准》条文说明第3.5.1条。<br>翼缘按S4级截面设计，腹板按S5级截面设计。</li><li>索结构索形状的确定，当荷载沿跨度和沿索长，对应形状是啥？<br>沿跨度是抛物线，沿索长是悬链线。<blockquote><p>学有余力的同学建议看看此处公式推导，大题第一道有可能会考！</p></blockquote></li><li>承载力抗震调整系数$\gamma_{RE}$小于1的原因？<br>见第四章PPT第60页。</li></ol>              </div>            </details></p><p>赶快行动吧，不然会很痛苦！</p><h1 id="第一章-轻型门式刚架"><a href="#第一章-轻型门式刚架" class="headerlink" title="第一章 轻型门式刚架"></a>第一章 轻型门式刚架</h1><h2 id="课上小测"><a href="#课上小测" class="headerlink" title="课上小测"></a>课上小测</h2><p><strong>去年期末试卷倒数第二题</strong>！！如下：<br><img src="/2024/OldBlogs/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/期末试卷倒数第二题.jpg" alt="期末试卷倒数第二题"></p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>压弯构件在弯剪共同作用下的强度验算。<br><div class="row">    <embed src="第一次作业-刚架柱验算.pdf" width="100%" height="550" type="application/pdf"></div><br>需要注意的是，由于截面只有部分有效，截面的形心和形心主轴已发生变化！形心坐标可根据以下公式求解：</p><script type="math/tex; mode=display">\overline { y } = \frac { \int y d S } { \int d S }</script><p>求解完之后，还需重新计算截面惯性矩，本质上都是依据<strong>平行移轴定理</strong>。后续截面比较复杂，可借助CAD求解截面特性，参考：<a href="https://www.zwcad.com/service_69_5076.html">CAD求解惯性矩</a>.</p><p>在第一次做的时候，很容易忽略这个点，究其根本，是对弯曲正应力公式的适用条件不太清楚。进一步，可深入了解一下广义弯曲正应力公式，后续有空来补坑。🤭<br><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap1%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A-%E5%88%9A%E6%9E%B6%E6%9F%B1%E9%AA%8C%E7%AE%97.pdf?e=1704723189&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:KrOUAs2ybutxK-DMuOmo4Ew6EvM=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div></p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><div class="row">    <embed src="第二次作业-檩条和压型钢板.pdf" width="100%" height="550" type="application/pdf"></div><ol><li>檩条计算<br>注意，最后求出有效截面后，不仅形心变了，而且形心主轴的方向也变了，此时不得不借助CAD求解形心主惯性矩，然后根据$\tan ( 2 \alpha ) = \frac { - 2 I _ { x y } } { I _ { x } - I _ { y } }$ 确定形心主惯性轴与平行于屋面得坐标系之间的夹角 $\alpha$，具体原理可详见《材料力学》。</li><li>压型钢板计算<br>此次作业注意压型钢板验算<strong>支座处腹板的局部受压承载力</strong>时，验算公式应为：<script type="math/tex; mode=display">R \leq n R _ { w }</script>式中<code>n</code>为所取压型钢板验算单元所含腹板数！也就是说，计算$R_{w}$的公式只是一块腹板的，需注意！</li></ol><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap1%20%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A-%E6%AA%A9%E6%9D%A1%E5%92%8C%E5%8E%8B%E5%9E%8B%E9%92%A2%E6%9D%BF.pdf?e=1704723326&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:3MgAj4KyqNNMzSapQ8DSiYSXasI=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div><h1 id="第二章-中、重型工业厂房"><a href="#第二章-中、重型工业厂房" class="headerlink" title="第二章 中、重型工业厂房"></a>第二章 中、重型工业厂房</h1><h2 id="第一次作业-1"><a href="#第一次作业-1" class="headerlink" title="第一次作业"></a>第一次作业</h2><div class="row">    <embed src="钢结构设计第二章作业.pdf" width="100%" height="550" type="application/pdf"></div><p>考试可能性最大的应该就是加强上翼缘的吊车梁验算(下图所示)了吧。其余两种，学有余力还是看看为好！不需要看如何求解内力M、N等，<strong>重在截面特性计算、强度验算</strong>！</p><div align="center"><img src="/2024/OldBlogs/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/习题2.3.jpg" width="90%"></div><p>注意，吊车横向荷载只由制动结构(加强上翼缘、制动桁架和制动梁)承受，求解抵抗矩$W_{y}$的时候要注意！</p><p>下面也给出了计算吊车梁截面影响线的程序和源码，程序可直接运行，用户可自定义输入<code>最大轮压标准值</code>、<code>吊车各轮距</code>、<code>吊车跨度</code>等参数。有兴趣的可以考完了解了解。</p><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap2%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A.pdf?e=1704723260&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:8BVXDaygH1M9v5oBQQ0sZ428B-U=" title="下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>下载pdf</a><a class="button no-text-decoration" href="http://qny.husj0711.top/Program/%E5%90%8A%E8%BD%A6%E6%A2%81%E5%86%85%E5%8A%9B%E5%8C%85%E7%BB%9C%E5%9B%BE%E6%B1%82%E8%A7%A3.exe?e=1704560118&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:7BpSdwI7QjA3daO0DLyIwRu-RL4=" title="下载程序"><i class="anzhiyufont anzhiyu-icon-bolt"></i>下载程序</a><a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap2%20%E5%90%8A%E8%BD%A6%E6%A2%81%E5%86%85%E5%8A%9B%E5%8C%85%E7%BB%9C%E5%9B%BE%E6%B1%82%E8%A7%A3.py?e=1704554410&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:qCT6Itrutw5cd3-E4qf6uKo-jU0=" title="下载源码"><i class="anzhiyufont anzhiyu-icon-bolt"></i>下载源码</a>          </div><h1 id="第三章-大跨空间结构"><a href="#第三章-大跨空间结构" class="headerlink" title="第三章 大跨空间结构"></a>第三章 大跨空间结构</h1><h2 id="课上小测-1"><a href="#课上小测-1" class="headerlink" title="课上小测"></a>课上小测</h2><div class="row">    <embed src="课上小测证明题.pdf" width="100%" height="550" type="application/pdf"></div><p>今天老师说不考下面的平衡-几何矩阵证明题，那么这个题考的可能性比较大，但这个不会太简单了吧，相比上学期难度降低许多，<strong>小心有坑</strong>！</p><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap3%20%E8%AF%BE%E4%B8%8A%E5%B0%8F%E6%B5%8B%E8%AF%81%E6%98%8E%E9%A2%98.pdf?e=1704723283&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:LKWBa88XblOudDj4uBdNqhbD1kg=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div><h2 id="第一次作业-2"><a href="#第一次作业-2" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>第一次做的时候，看了书和一些文献，其实就是验算<strong>结构平衡-几何矩阵互伴定理</strong>，开始是按结构矩阵分析一步步来的，略显繁琐。详见<a href="https://kns.cnki.net/kcms2/article/abstract?v=RyaFSLOYMk7J8_lxgL_sRXoQCgg-nTGKRzviJBbluTdA2OHlETWTOILYh91mLjoNUg0FIMOGuRxtO2Cju-mXuSw7vpi5Ttgm2gJ6ibKCmaRT9ElfmLNR9_PlSDbnMJM8CieDFwGLcI0=&amp;uniplatform=NZKPT&amp;language=CHS">结构平衡-几何矩阵互伴定理</a>.</p><p>大家有兴趣也可以看我最开始写的，<a href="http://www.husj0711.top/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">点击此处跳转</a>,位于<code>结构力学</code>板块下！</p><p>老师上课又讲了一遍，于是最近又重新按老师的方法写了一遍，遵循的就是<strong>力系平衡，变形协调</strong>！<br><div class="row">    <embed src="第三章第一次作业（老师推荐解法）.pdf" width="100%" height="550" type="application/pdf"></div></p><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap3%20%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%88%E8%80%81%E5%B8%88%E6%8E%A8%E8%8D%90%E8%A7%A3%E6%B3%95%EF%BC%89.pdf?e=1704723301&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:R5R_EBZSvwB-DmlVyJmZQiPuJK8=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div><h2 id="第二次作业-1"><a href="#第二次作业-1" class="headerlink" title="第二次作业"></a>第二次作业</h2><div class="row">    <embed src="第三章第二次作业.pdf" width="100%" height="550" type="application/pdf"></div><p>网架节点验算，如果给出设计内力，直接验算也是可以的，可是$\varphi$必须要查表，考的可能性也不是很大。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><div class="row">    <embed src="第三章第三次作业.pdf" width="100%" height="550" type="application/pdf"></div><p>这个考的可能性还是有的，利用虚功原理，比较简单。</p><h1 id="第四章-多、高层钢结构"><a href="#第四章-多、高层钢结构" class="headerlink" title="第四章 多、高层钢结构"></a>第四章 多、高层钢结构</h1><h2 id="第一次作业-3"><a href="#第一次作业-3" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>作业请参见文章<a href="http://www.husj0711.top/2023/Specific%20subject/02%20%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95%E6%B1%82%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E7%A8%8B%E6%9B%B2%E7%BA%BF/"><strong>中心差分法求相对位移时程曲线</strong></a></p><p>考试可能性为0，可略过。</p><hr><div class="tip success"><p><strong>完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</strong></p></div><p>感谢<a href="https://coe.ouc.edu.cn/2022/0527/c9093a371372/page.htm">谭启阳老师</a>的辛勤付出！</p><p>祝大家都能体会到钢结构设计的魅力！</p>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>振型分解反应谱法及相关系数推导</title>
      <link href="/2024/OldBlogs/05%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95%E6%8E%A8%E5%AF%BC/"/>
      <url>/2024/OldBlogs/05%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>整理自<a href="https://www.husj0711.top/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/">结构设计杂谈</a>. 理解本文需要阅读一下上述链接中资料或本身具有一定基础！<br>振型分解反应谱只适用于<strong>弹性分析</strong>。</p><p>下面开始正式推导！</p><h1 id="振型分解法"><a href="#振型分解法" class="headerlink" title="振型分解法"></a>振型分解法</h1><p><img src="地震动等效动荷载.jpg" alt="计算简图"><br>易知多自由度(这里设为n)结构体系在地震动作用下运动微分方程为:</p><script type="math/tex; mode=display">\tag{1} M\ddot X + C\dot X + KX =  - M\{ 1\} {\ddot x_g}</script><p>易知该结构体系无阻尼自由振动微分方程为$M\ddot X + KX = 0$，由高等数学知识可知，其解为$X = \varphi \sin \left( {wt} \right)$，再代入无阻尼自由振动微分方程中，由于$\omega  \ne 0$，$\varphi \ne {0}$，即得:</p><script type="math/tex; mode=display">\tag{2}- {\omega ^2}{M\varphi } + {K\varphi } = {0}</script><p>也即：</p><script type="math/tex; mode=display">{M}^{ - 1}{K\varphi }{\text{ = }}{\omega ^2}{\varphi }</script><p>由线性代数知识知，这等效于求${M^{ - 1}}K$的特征值和特征向量。于是解特征方程:</p><script type="math/tex; mode=display">\tag{3}\left| {K - {\omega ^2}M} \right| = 0</script><p>由于结构刚度矩阵K是正定的，一定能得到<strong>n个正特征值(允许有重根)和n个线性无关的特征向量</strong>！</p><blockquote><p>为啥能得到？见开头所讲资料；</p></blockquote><p>而且对于任意两个不同频率($\omega_{i}$、$\omega_{j}$)所对应的振型向量($\varphi_{i}$、$\varphi_{j}$)关于质量矩阵M、阻尼矩阵C和刚度矩阵K是正交的！</p><blockquote><p>事实上，对于重根的情况，也可以找到两个振型关于上述矩阵正交。具体原理可参加《结构动力学》（Chopra 著）。</p></blockquote><p>下面以质量矩阵M为例：<br>将$\varphi _i$和$\varphi _j$代入式(1)中，得：</p><script type="math/tex; mode=display">\tag{4}- w_i^2M{\varphi _i} + K{\varphi _i} = 0</script><script type="math/tex; mode=display">\tag{5}- w_j^2M{\varphi _j} + K{\varphi _j} = 0</script><p>将式(4)等式两边同乘以$\varphi _j^T$，式(5)等式两边同乘$\varphi _i^T$，并等式两边同时转置，有:</p><script type="math/tex; mode=display">\tag{6} - \omega _i^2\varphi _j^TM{\varphi _i} + \varphi _j^TK{\varphi _i} = 0</script><script type="math/tex; mode=display">\tag{7} - \omega _j^2\varphi _j^TM{\varphi _i} + \varphi _j^TK{\varphi _i} = 0</script><blockquote><p>M、K由于是对称矩阵，其转置等于自身。</p></blockquote><p>式(6)-式(7)，得到：</p><script type="math/tex; mode=display">\left( {\omega _j^2 - \omega _i^2} \right)\varphi _j^TM{\varphi _i} = 0</script><p>由于$\omega_{i} \ne \omega_{j}$，则有</p><script type="math/tex; mode=display">\varphi _j^TM\varphi _i = 0</script><p>得证！</p><p>由于n个特征向量线性无关，故可作为一组基来表示结构的位移，即$X = \sum {({q_i(t)}{\varphi _i})} $，t表示第t时刻，将X表达式代入式(1)，有：<br>$$ M\{ \sum {\left( {{{\ddot q}_i}{\varphi _i}} \right)} \}  + C\{ \sum {\left( {{{\dot q}_i}{\varphi _i}} \right)} \}  + K\{ \sum {\left( {{q_i}{\varphi _i}} \right)} \}  =  - M\{ 1\} {\ddot x_g} $$</p><p>上式等式两边同左乘$\varphi _i^T$，根据振型向量的正交性，有：</p><script type="math/tex; mode=display">\varphi _i^TM{\ddot q_i}{\varphi _i} + \varphi _i^TC{\dot q_i}{\varphi _i} + \varphi _i^TK{q_i}{\varphi _i} =  - \varphi _i^TM\{ 1\} {\ddot x_g}</script><p>也即：</p><script type="math/tex; mode=display">\tag{8} \varphi _i^TM{\varphi _i}{\ddot q_i} + \varphi _i^TC{\varphi _i}{\dot q_i} + \varphi _i^TK{\varphi _i}{q_i} =  - \varphi _i^TM\{ 1\} {\ddot x_g}</script><p>记${M_i} = \varphi _i^TM{\varphi _i},{C_i} = \varphi _i^TC{\varphi _i},{K_i} = \varphi _i^TK{\varphi _i}{q_i}$，分别称为<strong>第i阶振型的广义质量、阻尼和刚度矩阵</strong>。</p><p>于是就有：</p><script type="math/tex; mode=display">\tag{9} {M_i}{\ddot q_i} + {C_i}{\dot q_i} + {K_i}{q_i} =  - \varphi _i^TM\{ 1\} {\ddot x_g}</script><p>式(9)还可以表示为：<br>$$ {M_i}{\ddot q_i} + {C_i}{\dot q_i} + {K_i}{q_i} =  - \frac{{\varphi _i^TM\{ 1\} }}{M_i}{M_i}{\ddot x_g}$$</p><p>现记${\gamma _i} = \frac{ {\varphi _i^TM\{ 1\} } }{ { {M_i} } } = \frac{ {\varphi _i^TM\{ 1\} } }{ {\varphi _i^TM{\varphi _i} } }$，称为<strong>第i阶振型的振型参与系数</strong>。</p><p>易知振型参与系数满足如下关系：</p><script type="math/tex; mode=display">\tag{10} \sum {\left( { {\gamma _i}{\varphi _i} } \right) = \{ 1\} }</script><p>证明如下：<br>式(10)等式两端同左乘${\varphi _i}^TM$，根据振型的正交性，有：</p><script type="math/tex; mode=display">{\gamma _i}\varphi _i^TM{\varphi _i} = \varphi _i^TM\{ 1\}</script><p>由此，显然有：</p><script type="math/tex; mode=display">{\gamma _i} = \frac{ {\varphi _i^TM\{ 1\} } }{ {\varphi _i^TM{\varphi _i} } }</script><p>得证！</p><p>令 ${D_i} = \frac{q_i}{\gamma _i}$，记为第i阶振型的地震响应时程。<br>于是式(9)就转化为：</p><script type="math/tex; mode=display">{M_i}{\ddot D_i} + {C_i}{\dot D_i} + {K_i}{D_i} =  - {M_i}{\ddot x_g}</script><p>从上式可以看出，第i振型的振动满足单自由度结构体系受迫振动运动微分方程。<br>对于给定的地震动时程，可以利用求解单自由度体系方法获得第i振型的地震响应时程$D_i$。由于i的任意性，可以看出在t时刻，多自由度结构体系各振型均满足单自由度结构体系受迫振动运动微分方程。通过振型叠加，即可获得各自由度的位移相对时程：</p><script type="math/tex; mode=display">X = \sum\limits_{i = 1}^n {\left( { {D_i}{\gamma _i}{\varphi _i} } \right)}</script><p>这种利用<strong>振型的正交性</strong>，将多自由度结构体系振动解耦成单自由度结构体系振动的方法称为<strong>振型分解法</strong>！</p><h1 id="振型分解反应谱法"><a href="#振型分解反应谱法" class="headerlink" title="振型分解反应谱法"></a>振型分解反应谱法</h1><p>在前述基础上，引入反应谱的概念。<br>常用的反应谱包括<strong>加速度反应谱和位移反应谱(亦称伪加速度反应谱)</strong>，下面以位移谱为例进行推导。<br>位移谱定义：<br>$$\alpha  = \frac{{{K_i}{D_{i\_\max }}\left( T \right)}}{{{M_i}g}}$$</p><p>对于第i阶振型，其地震响应时程最大值的标准值为:<br>$${D_{i\_k}} = \frac{{{\alpha _i}{M_i}g}}{{{K_i}}} = \frac{{{\alpha _i}g}}{{\omega _i^2}}$$</p><p>则第i振型最大位移为：</p><script type="math/tex; mode=display">{X_i} = {D_{i\_k}}{\gamma _i}{\varphi _i}</script><blockquote><p>因为${\gamma _i}{\varphi _i}$是定值，$D_{i}$取最大，即$X_i$取最大。</p></blockquote><p>我们认为结构处于最大位移时最不利，相应的地震作用为：<br>$$\begin{align*}F_i &= KX_i = KD_{i\_k}\gamma_i\varphi_i = K\frac{\alpha_ig}{\omega_i^2}\gamma_i\varphi_i = \frac{\alpha_ig}{\omega_i^2}\gamma_iMM^{-1}K\varphi_i \\    &= \frac{\alpha_ig}{\omega_i^2}\gamma_iM\omega_i^2\varphi_i \\    &= \tag{11}\alpha_i\gamma_igM\varphi_i\end{align*}$$</p><p>这样，我们就得到了第i阶振型所对应的地震作用啦！<br>对于第j个质点，其所受地震作用为：</p><script type="math/tex; mode=display">\tag{12}{F_{i,j} } = {\alpha _i}{\gamma _i}g{m_j}{\varphi _{i,j} }</script><p><strong>作用效应组合</strong>：采用平方和开平方法(SRSS法)</p><script type="math/tex; mode=display">\sqrt {\sum\limits_{i = 1}^n {\left( {S_i^2} \right)} }</script><h1 id="振型参与质量系数与振型有效质量系数"><a href="#振型参与质量系数与振型有效质量系数" class="headerlink" title="振型参与质量系数与振型有效质量系数"></a>振型参与质量系数与振型有效质量系数</h1><p>疑惑起源：<br>《抗规》中提到，振型个数一般需要取振型参与质量累计达到总质量90%所需的振型数。</p><p>第i阶振型的地震作用：</p><script type="math/tex; mode=display">F_i = \alpha_i\gamma_igM\varphi_i</script><p>上式可以写成：<br>$${F_i} = {\alpha _i}{\gamma _i}Mg{\varphi _i} = \frac{{{\alpha _i}g}}{{\ddot x}_{g\_\max }}M{\ddot x_{g\_\max }}{\gamma _i}{\varphi _i}$$<br>这里我们称 $\frac{ { {\alpha _i}g} }{ { { {\ddot x}_{g_\max } } } }$ 为动力放大系数，记为$\beta$，即：</p><script type="math/tex; mode=display">\beta = \frac{ { {\alpha _i}g} }{ { { {\ddot x}_{g\_\max } } } }</script><p>其中$M{\ddot x_{g_\max }}{\gamma _i}{\varphi _i}$为<strong>地震动最大加速度的等效动荷载在第i阶振型上的分量</strong>。</p><p>则$F_i$产生的效应可以写成：<br>$${S_i} = S\left( {{F_i}} \right) = \beta S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)$$<br>可见，地震动最大加速度的等效动荷载在第i阶振型上的分量引起的结构响应越大，地震响应系数$\alpha_{i}$越大，则第i振型对应的效应就越大.</p><p>对于线弹性体系，有：<br>$$S\left( {M\{ 1\} {{\ddot x}_{g\_\max }}} \right) = S\left( {M\sum {\left( {{\gamma _i}{\varphi _i}} \right){{\ddot x}_{g\_\max }}} } \right) = \sum {\left( {S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)} \right)}$$</p><p>令<br>$${\mu _{S\_j}} = \frac{{\sum\limits_{i = 1}^j {\left( {S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)} \right)} }}{{\sum\limits_{i = 1}^n {\left( {S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)} \right)} }}$$<br>称$\mu_{S_j}$为<strong>效应S的振型有效质量系数。</strong></p><p>一般来讲，结构的<strong>基底剪力(首层剪力)</strong>能够很好地反映结构的整体响应。<br>式(12)为第i阶振型第j个质点所受地震水平力，则基底剪力可以表示为：</p><p>易知基底剪力可以表示为：</p><script type="math/tex; mode=display">{F_{BS}} = {\{ 1\} ^T}{\alpha _i}{\gamma _i}Mg{\varphi _i}</script><p>则基底剪力的振型有效质量系数$\mu _{BS_j}$为:<br>$$\begin{align*}{\mu _{BS\_j}} &= \frac{{\sum\limits_{i = 1}^j {\left( {{{\{ 1\} }^T}{\alpha _i}{\gamma _i}Mg{\varphi _i}} \right)} }}{{\sum\limits_{i = 1}^n {\left( {{{\{ 1\} }^T}{\alpha _i}{\gamma _i}Mg{\varphi _i}} \right)} }} = \frac{{\sum\limits_{i = 1}^j {\left( {{{\{ 1\} }^T}{\gamma _i}M{\varphi _i}} \right)} }}{{{{\{ 1\} }^T}M\sum\limits_{i = 1}^n {\left( {{\gamma _i}{\varphi _i}} \right)} }} = \frac{{\sum\limits_{i = 1}^j {\left( {{{\{ \sum {{\gamma _i}{\varphi _i}} \} }^T}{\gamma _i}M{\varphi _i}} \right)} }}{{{{\{ 1\} }^T}M\{ 1\} }} \\   &= \frac{{\sum\limits_{i = 1}^j {\left( {{\gamma _i}\varphi _i^T{\gamma _i}M{\varphi _i}} \right)} }}{{\sum\limits_{i = 1}^n {{m_i}} }}\\    &= \frac{{\sum\limits_{i = 1}^j {\left( {\gamma _i^2{M_i}} \right)} }}{{\sum\limits_{i = 1}^n {{m_i}} }}\end{align*}$$</p><p>进一步，令</p><script type="math/tex; mode=display">M_i^* = \gamma _i^2{M_i}</script><p>称$M_i^*$为第i阶振型的基底剪力振型参与质量。</p><p>自然而言，有<strong>第i阶振型的基底剪力振型参与质量系数</strong>:</p><script type="math/tex; mode=display">\mu_{i} = \frac{ {M_i^*} }{ {\sum\limits_{i = 1}^n { {m_i} } } }</script><p>易知其满足：</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^n { {\mu _i} }  = 1</script><p>如前述所说，结构的基底剪力能够很好地反映结构的整体响应，所以我们一般就采用基底剪力振型参与质量系数和基底剪力有效质量系数，并简称<strong>振型参与质量系数与振型有效质量系数</strong>！</p><p>先写到这吧，还挺多的呢，敬请期待(☆▽☆)</p>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 振型分解反应谱法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程造价计算题</title>
      <link href="/2024/OldBlogs/04%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7%E8%AE%A1%E7%AE%97%E9%A2%98/"/>
      <url>/2024/OldBlogs/04%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7%E8%AE%A1%E7%AE%97%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip warning"><p>需要注意的是，本文所提供的下载链接只保持三天！！！过期如有需要可在下方或者在<code>友链-&gt;留言板</code>处留言！</p></div><div class="tip warning"><p>如果pdf未显示，刷新一下即可！(●ˇ∀ˇ●)</p></div><p>考试题型：</p><ol><li>选择题(2/20),共计40分.<br>考察概念和简单计算，包括但不限于：进口设备购置费、定额原理、劳动单价、预备费和建设期贷款利息等等。</li><li>判断对错题, 10分.</li><li>计算题<br>综合单价一道(10分)，工程结算一道(30分)。 </li><li>综合分析题(类似于论述题)，考察对这门课的认识。(10分)<br>估计是老师捞人的，加油加油！😊</li></ol><p>所有PPT中<strong>第8讲、第9讲PPT</strong>可以不用看。<br>给刚复习的人的福利(●ˇ∀ˇ●)—&gt;<a href="http://qny.husj0711.top/pdf/%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7-%E5%BB%BA%E8%AE%BE%E5%B7%A5%E8%B5%84.pdf?e=1704990745&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:j6X1gyBHKNKiu7dqFz6vmt9vBNk=">点击开始下载</a></p><p>奥里给！！<br>下面为PPT上没有答案的例题：</p><h1 id="第2讲工程项目投资构成1"><a href="#第2讲工程项目投资构成1" class="headerlink" title="第2讲工程项目投资构成1"></a>第2讲工程项目投资构成1</h1><div class="row">    <embed src="第2讲工程项目投资构成1.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第3讲工程项目投资构成2"><a href="#第3讲工程项目投资构成2" class="headerlink" title="第3讲工程项目投资构成2"></a>第3讲工程项目投资构成2</h1><div class="row">    <embed src="第3讲工程项目投资构成2.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第4讲工程项目投资构成3"><a href="#第4讲工程项目投资构成3" class="headerlink" title="第4讲工程项目投资构成3"></a>第4讲工程项目投资构成3</h1><p>涨价预备费计算公式：</p><script type="math/tex; mode=display">涨价预备费= \sum I _ { t } [ ( 1 + f ) ^ { t } - 1 ]</script><p>式中t为第t年，f为价格上涨率, $I_{t}$表示第t年的静态投资。</p><div class="row">    <embed src="第4讲工程项目投资构成3.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第5讲建筑工程定额原理1"><a href="#第5讲建筑工程定额原理1" class="headerlink" title="第5讲建筑工程定额原理1"></a>第5讲建筑工程定额原理1</h1><p>注意：<strong>残值率==回收折价率</strong>！<br>下面PDF中有问题，考试肯定直接给回收折价率，套公式即可！<br><div class="row">    <embed src="第5讲建筑工程定额原理1.pdf" width="100%" height="550" type="application/pdf"></div></p><h1 id="第7讲工程量及其计算规则1"><a href="#第7讲工程量及其计算规则1" class="headerlink" title="第7讲工程量及其计算规则1"></a>第7讲工程量及其计算规则1</h1><p>这里需要自己看看<code>清单计价规范</code>和<code>定额计价规范</code>才好理解，规范下载在BB平台上。<br>第8讲PPT老师没有讲，可以略过。<br>第9讲广联达计算也可以略过。</p><div class="row">    <embed src="第7讲工程量及其计算规则1.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第15讲工程结算"><a href="#第15讲工程结算" class="headerlink" title="第15讲工程结算"></a>第15讲工程结算</h1><p><strong>这个题目非常重要，占30分</strong>！！！<br>每期工程结算款就按下述公式来：</p><div align="center"><img src="/2024/OldBlogs/04%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7%E8%AE%A1%E7%AE%97%E9%A2%98/工程款结算.jpg" width="90%"></div><hr><div class="row">    <embed src="第15讲工程结算.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2024/OldBlogs/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/OldBlogs/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建"><a href="#个人博客搭建" class="headerlink" title="个人博客搭建"></a>个人博客搭建</h1><ol><li>安装<a href="https://nodejs.org/en">Nodejs</a>,这里选择<code>LTS</code>版本，安装好后，运行如下命令(建议使用以管理员方式运行,例如将git bash设置为以管理员方式打开，我是选择始终以管理方式运行git bash)，检查nodejs安装是否成功。<a href="https://git-scm.com/"><strong>Git下载</strong></a>,建议装在系统盘(例如C盘)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查nodejs是否安装成功</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看npm下载的全局保存目录(prefix)和缓存位置(cache)</span></span><br><span class="line"><span class="comment"># 如果在C盘，可以换到D盘某个位置，例如就在Nodejs安装路径下新建`node_global`和`node_cache`两个文件夹。</span></span><br><span class="line"><span class="comment"># 然后更改`Nodejs安装路径\node_modules\npm`下的npmrc和.npmrc文件，加上上述两个文件夹的路径。</span></span><br><span class="line">npm config <span class="built_in">ls</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将Nodejs中的全局保存目录（保存下载的库）和<code>Nodejs安装路径\node_modules\npm</code>放到系统变量中的Path下，如下图所示。</p><div align="center"><img src="/2024/OldBlogs/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/nodejs添加环境变量.jpg" width="70%"></div><blockquote><p>其中全局保存目录是为了后面<code>hexo</code>命令能顺利运行，而<code>...\npm</code>文件夹则是为了npm能顺利运行。</p></blockquote></li><li><p>然后在博客文件夹（必须是新文件夹）(这里以<code>D:\Blog</code>举例),git bash,运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli <span class="comment">#(下载到全局保存目录)</span></span><br><span class="line"></span><br><span class="line">hexo init <span class="comment"># 博客初始化</span></span><br><span class="line"></span><br><span class="line">npm install hexo-cli  <span class="comment">#下载hexo到`D:\Blog\node_modules`</span></span><br><span class="line"></span><br><span class="line">hexo -v <span class="comment"># 若成功显示版本，则表示hexo安装成功了。</span></span><br><span class="line"></span><br><span class="line">hexo g  </span><br><span class="line"></span><br><span class="line">hexo s  <span class="comment"># 然后再本地打开即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样博客就初步搭建完成了。</span></span><br></pre></td></tr></table></figure></li><li>可以运行<code>hexo new  xxx.md</code>来生成文章，然后运行<code>hexo g</code>，等待部署到github上。</li><li>参考：<a href="https://blog.csdn.net/m0_48121128/article/details/132380427"><strong>完成hexo到GitHub的部署</strong></a>，这里要注意，在博客目录下config.yaml修改时（如下）：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repo:</span> <span class="string">git@github.com:Yourname/Yourname.github.io.git</span>   <span class="comment"># 这里不要用https: 链接，否则后面部署时傻里傻气的。</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment">#这里分支要选择好，main是默认的，可以新建分支(比如source)，但要对应github-pages那里生成的分支，如下图所示。</span></span><br></pre></td></tr></table></figure><div align="center"><img src="/2024/OldBlogs/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github%20pages生成选择分支.jpg" width="70%"></div><br>（注意，这里首先需要利用git建立与GitHub账户的ssh连接，然后再在hexo中设置用git进行版本更新，即type=git，这样每次更新就不用输入GitHub密码了，直接更新即可。）</li><li>再运行<code>npm install hexo-deployer-git --save</code>（否则<code>hexo d</code>无效，无法完成部署）。</li></ol><p><strong>参考资料</strong></p><ol><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029"><strong>搭建个人博客</strong></a></li></ol><h1 id="博客优化"><a href="#博客优化" class="headerlink" title="博客优化"></a>博客优化</h1><h2 id="hexo-d-显示无法连接到-github"><a href="#hexo-d-显示无法连接到-github" class="headerlink" title="hexo d 显示无法连接到 github."></a>hexo d 显示无法连接到 <code>github</code>.</h2><p>运行的<code>hexo d</code>后会报错：</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/Hushuangjun/Hushuangjun.github.io.git">https://github.com/Hushuangjun/Hushuangjun.github.io.git</a></p></blockquote><p>解决方法：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_46087812/article/details/124575202</span><br></pre></td></tr></table></figure></p><p>如果在搭建过程中，在 <code>_config.yml</code>中设置如下则不会报这个错：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:Hushuangjun/Hushuangjun.github.io.git</span>      <span class="comment">#使用git进行下载，而不是https!</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">theme_anzhiyu</span>    <span class="comment">#对应GitHub上要同步的分支</span></span><br></pre></td></tr></table></figure></p><h2 id="markdown如何插入本地图片"><a href="#markdown如何插入本地图片" class="headerlink" title="markdown如何插入本地图片"></a>markdown如何插入本地图片</h2><p>实际上这个属于markdown的基本语法，使用相对路径即可。<br>GitHub上有作者开发了插件<a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-iamge</a>,更加方便了！<br>参考：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/koo070/p/16548228.html</span><br></pre></td></tr></table></figure></p><h2 id="博客中如何插入自定义大小图片？"><a href="#博客中如何插入自定义大小图片？" class="headerlink" title="博客中如何插入自定义大小图片？"></a>博客中如何插入自定义大小图片？</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/139007418</span><br></pre></td></tr></table></figure><h2 id="博客内嵌pdf直接下载而不显示"><a href="#博客内嵌pdf直接下载而不显示" class="headerlink" title="博客内嵌pdf直接下载而不显示"></a>博客内嵌pdf直接下载而不显示</h2><p>因为我们idm插件接管了那个命令，只要把浏览器的idm插件关闭或者设置在该网站不再自动下载。</p><h2 id="hexo-d每次都需要绑定域名"><a href="#hexo-d每次都需要绑定域名" class="headerlink" title="hexo d每次都需要绑定域名"></a>hexo d每次都需要绑定域名</h2><p>为啥每次<code>hexo d</code>后，在<code>settings-pages</code>那里都要重新配置<code>custom domain</code>?<br>为避免这个麻烦，可以在博客目录下<code>source</code>文件夹下新建<code>CNAME</code>,内容为需要绑定的域名(我的为<code>husj0711.top</code>)。<br>参考<a href="https://blog.csdn.net/weixin_49175501/article/details/128705141">解决方案</a>。</p><h2 id="博客在本地-localhost-4000-查看可以，网络打开排版很乱。"><a href="#博客在本地-localhost-4000-查看可以，网络打开排版很乱。" class="headerlink" title="博客在本地(localhost:4000)查看可以，网络打开排版很乱。"></a>博客在本地(localhost:4000)查看可以，网络打开排版很乱。</h2><p><code>Shift + F5</code>强制刷新页面即可。</p><h2 id="博客文章如何显示数学公式？"><a href="#博客文章如何显示数学公式？" class="headerlink" title="博客文章如何显示数学公式？"></a>博客文章如何显示数学公式？</h2><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>博客采用Mathjax语法显示数学公式。<br>hexo-renderer-marked是hexo默认的渲染器，不支持复杂的数学公式，正是我需要换掉的，安装<strong>hexo-renderer-kramed</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><br>然后修改主题配置文件为：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>博客配置文件中添加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>目前的工作流：<br>首先，mathtype敲公式，然后复制，复制配置如下：<br><img src="/2024/OldBlogs/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/mathtype剪切复制.jpg" alt="mathtype"></p><p>复制得到的公式为：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\frac&#123;&#123; - b \pm \sqrt &#123;&#123;b^2&#125; - 4ac&#125; &#125;&#125;&#123;&#123;2a&#125;&#125;\]</span><br></pre></td></tr></table></figure><br>由于hexo-renderer-kramed不支持<code>\]</code>，故要换成<code>$$</code>(行间)或者<code>$</code>(行内).也即：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;&#123; - b \pm \sqrt &#123;&#123;b^2&#125; - 4ac&#125; &#125;&#125;&#123;&#123;2a&#125;&#125;$$</span><br></pre></td></tr></table></figure></p><p>但是上述还会出现一个问题，多个<code>&#123;</code>之间没有空格，也是渲染报错，需要在它们中间加上空格，或者在公式前后加上<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125; </span><br><span class="line">...</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><br>故有：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123; &#123; - b \pm \sqrt &#123; &#123;b^2&#125; - 4ac&#125; &#125; &#125;&#123; &#123;2a&#125; &#125;$$</span><br></pre></td></tr></table></figure><br>或者<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">$$\frac&#123;&#123; - b \pm \sqrt &#123;&#123;b^2&#125; - 4ac&#125; &#125;&#125;&#123;&#123;2a&#125;&#125;$$</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></p><p>最终显示效果：</p><script type="math/tex; mode=display">\frac{ { - b \pm \sqrt { {b^2} - 4ac} } }{ {2a} }</script><p>至此，绝大数公式就能显示啦！</p><h3 id="自动编号公式"><a href="#自动编号公式" class="headerlink" title="自动编号公式"></a>自动编号公式</h3><p>在LaTeX中，{equation}环境用于创建单个公式，这些公式会自动带有编号。例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">E = mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h3 id="手动指定公式编号"><a href="#手动指定公式编号" class="headerlink" title="手动指定公式编号"></a>手动指定公式编号</h3><p>如果你想要为公式手动指定编号，可以在{equation}环境中使用\tag{}命令。例如，使用\tag{1}将会以“(1)”作为公式的编号：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">E = mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\tag</span>&#123;1&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h3 id="不编号的公式"><a href="#不编号的公式" class="headerlink" title="不编号的公式"></a>不编号的公式</h3><p>若要插入不编号的公式，你可以使用[ … ]或者{equation<em>}环境。为了使用{equation</em>}环境，你需要在文档的导言区引入{amsmath}宏包。</p><p>使用[ … ]的例子：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\[</span></span><br><span class="line">E = mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure><p>使用{equation*}环境的例子：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation*&#125;</span><br><span class="line">E = mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation*&#125;</span><br></pre></td></tr></table></figure><h2 id="博客utterances评论系统"><a href="#博客utterances评论系统" class="headerlink" title="博客utterances评论系统"></a>博客utterances评论系统</h2><p>这个是针对<code>NexT</code>主题的！！！<br>参考：</p><ol><li><a href="https://bambrow.com/20230625-hexo-comment-utterances/#more">Hexo NexT 使用 utterances 评论区</a></li><li><a href="https://utteranc.es/?installation_id=45240142&amp;setup_action=install">utterances</a></li></ol><p>上述文献[2]中，需要将下列代码添加到博客模板文件(<code>D:\Blog\themes\next\layout\_layout.njk</code>)中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span><br><span class="line">        repo=<span class="string">&quot;[ENTER REPO HERE]&quot;</span></span><br><span class="line">        issue-term=<span class="string">&quot;[ENTER TERM HERE]&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;github-light&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="hexo-init报错"><a href="#hexo-init报错" class="headerlink" title="hexo init报错"></a>hexo init报错</h2><p>当我们在git bash中运行<code>hexo init</code>时，得到如下报错：</p><blockquote><p>Failed to connect to github.com port443after21090ms：Couldn ‘t connect to server;</p></blockquote><p>这个是因为我们使用VPN后，系统端口号与Git端口号不一致时导致的，具体可参考这篇<a href="https://www.cnblogs.com/51net/p/18753877">解决方案</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zotero 插件推荐</title>
      <link href="/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/"/>
      <url>/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Zotero-better-notes"><a href="#Zotero-better-notes" class="headerlink" title="Zotero better notes"></a>Zotero better notes</h1><p>Zotero借助插件<strong>zotero better notes</strong>可以很好地实现markdown写作。<br><img src="//husj0711.top/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/zotero-better-notes实现markdown写作.jpg" alt="Zotero better notes"></p><p>那么如何实现笔记同步呢？<br>选中某个笔记，右键，选择导出笔记。<br><img src="//husj0711.top/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/zotero笔记同步-1.jpg" alt="zotero导出笔记-1"></p><p>然后在弹出来的框中勾选如下选项：<br><img src="//husj0711.top/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/zotero笔记同步-2.jpg" alt="zotero导出笔记-2"></p><p>导出的笔记存放至某个文件夹，然后在zotero中点击同步管理器，就能看到同步的文件夹啦！<br><img src="//husj0711.top/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/zotero笔记同步-3.jpg" alt="zotero导出笔记-3"></p><h1 id="Zotfile"><a href="#Zotfile" class="headerlink" title="Zotfile"></a>Zotfile</h1><p>借助<a href="https://github.com/jlegewie/zotfile">zotfile</a>插件可以实现pdf附件以资源管理器那样文件夹式分类存储，条理清晰！如下图所示：<br><img src="//husj0711.top/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/zotfile实现文件夹式分类.jpg" alt="Zotfile"></p><p>具体可以看我下面这个视频。</p><div style="display: flex; justify-content: center;">    <iframe src="//player.bilibili.com/player.html?aid=351016062&bvid=BV1sR4y1b7rB&cid=987099716&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="800" height="450"></iframe></div><p>下载地址：<a href="https://github.com/windingwind/zotero-better-notes">zotero better notes</a></p><h1 id="Zotero-PDF-translate"><a href="#Zotero-PDF-translate" class="headerlink" title="Zotero PDF translate"></a>Zotero PDF translate</h1><p>Zotero PDF translate可以实现选词翻译，在阅读英文文章过程中很好用！<br>缺点就是不用科学上网的话体验比较糟糕！<br><img src="//husj0711.top/2024/OldBlogs/Zotero%20%E6%8F%92%E4%BB%B6/zotero翻译插件.jpg" alt="zotero pdf transalte"></p><p>下载地址：<a href="https://github.com/windingwind/zotero-pdf-translate">Zotero PDF translate</a></p><p>更多内容请参见<a href="https://zotero-chinese.com/user-guide/organize-library.html">Zotero中文社区</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 科研工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 系列配置</title>
      <link href="/2024/OldBlogs/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
      <url>/2024/OldBlogs/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode配置C"><a href="#VScode配置C" class="headerlink" title="VScode配置C"></a>VScode配置C</h1><ol><li>由于C语言是编译型语言，而vscode仅仅是一个代码编辑器，故需要先配置编译器，这里我选择mingw-w64的<a href="https://sourceforge.net/projects/mingw-w64/files/"><strong>gcc编译器</strong></a>。注意下载后需要将”….\mingw64\bin”放到环境变量（系统和用户环境变量都可，选一种即可）。</li><li>然后在vscode上下载扩展插件(C/C++),这里要注意，尽量安装版本较老的，否则不会自动生成launch.json文件。如果实在没法自动生成，可自己配置，参考<a href="https://blog.csdn.net/m0_63702526/article/details/130136859">VSCode配置C/C++</a>等多篇文章.</li><li>配置好之后，可以运行C/C++源文件了，但发现：<strong>终端窗口在程序一运行完就立即消失了</strong>，于是上网查阅了各种办法，选择了两种运行方式：（具体见配置文件 <code>launch.json</code> 和<code>tasks.json</code>。当然，两者都是gcc编译的。）<ol><li>在外终端（C:\WINDOWS\system32\cmd.exe）运行可执行文件(.exe)。</li><li>在内终端(D:\Computer Softwares\Visual studio code\Codes..)(即项目所在地址，相当于直接git bash here) 运行可执行文件(.exe)。</li></ol></li><li>但是很快就发现一个问题，外终端运行时打印汉字会乱码，于是在<code>tasks.json</code>文件中增加<code>&quot;-fexec-charset=GBK&quot;</code>，但很快就发现，内终端运行时就乱码了。于是查阅<a href="https://blog.csdn.net/weixin_43439450/article/details/118331694"><strong>网上一些资料</strong></a>，进行如下操作即可实现内外终端均不会乱码。<ol><li>将cmd的编码（解码）方式由默认的<code>gbk</code>换成<code>utf-8</code>,具体参考<a href="https://blog.csdn.net/qq_43768851/article/details/123501124"><strong>如何更改cmd的编/解码格式</strong></a>.</li><li>将gcc的编/解码方式也换成<code>utf-8</code>,(这也是gcc默认的)，在<code>tasks.json</code>文件中增加<code>&quot;-finput-charset=UTF-8&quot;</code>,删掉原来的<code>&quot;-fexec-charset=GBK&quot;</code>.</li></ol></li><li>至此，就完成了VScode对C/C++的配置！<br>注意：<ol><li><strong>项目所在地址应为英文路径</strong>，否则编译器会报错。</li><li>配置好的<code>c_cpp_properties.json</code>、<code>lanuch.json</code>和<code>task.json</code>见<a href="https://pan.baidu.com/s/1PKbGVBoxTYaMnY56qU3W2w?pwd=8jda">链接</a>,提取码:8jda.将这三个文件放入<code>.vscode</code>文件夹下，即可完美运行<strong>C源文件</strong>，对于<strong>C++源文件</strong>目前还未测试。</li><li>对于多个C文件同时运行是不支持的，可能因为<strong>编译生成的程序名称还是以c源文件名称来命名的原因吧</strong>，可能要在task.json和launch.json文件下改。<ol><li>对的，task.json中args参数改动：：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">改为<span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;\\*.c&quot;</span><span class="punctuation">,</span><span class="comment">//c++代码就改这里后缀为.cpp</span></span><br><span class="line"><span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;\\$&#123;workspaceRootFolderName&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>launch.json文件改动如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;\\$&#123;workspaceRootFolderName&#125;.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li>这样就变成VS了，会编译项目文件下所有C文件，集成到以项目名称命名的程序下。</li></ol></li></ol></li></ol><h1 id="VSCode配置python虚拟环境"><a href="#VSCode配置python虚拟环境" class="headerlink" title="VSCode配置python虚拟环境"></a>VSCode配置python虚拟环境</h1><ol><li><strong>安装 Python 插件：</strong><ul><li>打开 VSCode。</li><li>在扩展视图中搜索并安装 Python 插件（一般是由 Microsoft 提供的 Python 插件）。</li></ul></li><li><p><strong>创建虚拟环境：</strong></p><ul><li>打开 VSCode 中的终端（可以使用 <code>Ctrl +</code> <code> </code> 或者点击顶部菜单的“视图”-&gt;“终端”）。</li><li><p>在终端中使用以下命令创建虚拟环境（假设你的项目在当前目录下，你可以替换 <code>venv</code> 为你喜欢的虚拟环境名称）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><p>如果你使用的是 Python 3.3 或更早版本，可以使用 <code>virtualenv</code> 替代 <code>venv</code>。</p></li></ul></li><li><p><strong>激活虚拟环境：</strong></p><ul><li><p>在终端中使用以下命令激活虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\venv\Scripts\activate</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>安装所需的包：</strong><ul><li>在虚拟环境中，使用 <code>pip</code> 安装你项目所需的依赖包，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>在 VSCode 中选择虚拟环境：</strong><ul><li>打开你的项目文件夹。</li><li>在左下角的状态栏中，你应该能够看到当前使用的 Python 解释器。如果没有显示，点击并选择虚拟环境的 Python 解释器。</li></ul></li></ol><p>注：也可以使用miniconda创建和管理虚拟环境，可参考:<a href="https://blog.csdn.net/sizhi_xht/article/details/80964099">anaconda创建python虚拟环境</a>。</p><p><strong>参考资料</strong></p><ol><li><a href="https://baijiahao.baidu.com/s?id=1767913548598914679&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1767913548598914679&amp;wfr=spider&amp;for=pc</a>)</li></ol><p><strong>Python-Pyinstaller 实现程序打包</strong><br>示例：<code>pyinstaller -F -c -i icon.ico myscript.py</code>.</p><p>可参考<a href="https://blog.csdn.net/BearStarX/article/details/81054134">pyinstaller参数介绍以及总结</a></p><h1 id="VSCode配置JAVA环境"><a href="#VSCode配置JAVA环境" class="headerlink" title="VSCode配置JAVA环境"></a>VSCode配置JAVA环境</h1><p>参考博客：</p><ol><li><a href="https://blog.csdn.net/m0_59836361/article/details/134264369">vscode搭建java开发环境</a>:基本是可以行的通的，如果遇到下载插件后找不到JDK，可能在<code>setting.json</code>中配置<code>&quot;java.jdt.ls.java.home&quot;: &quot;D:/JDK17&quot;</code>，可以稍微参考一下第二篇博客。</li><li><a href="https://blog.csdn.net/weixin_40448140/article/details/105904836">VScode 配置 Java 开发环境 (VSCode 天下第一!!!!!)</a>: 由于JDK版本和插件更新迭代，设置稍微有点不同。2024.10.12，JDK17.0，设置方法为：<code>&quot;java.jdt.ls.java.home&quot;: &quot;D:/JDK17</code>.</li></ol><h1 id="VScode通过ssh连接远程服务器"><a href="#VScode通过ssh连接远程服务器" class="headerlink" title="VScode通过ssh连接远程服务器"></a>VScode通过ssh连接远程服务器</h1><p>一般有两种方法：</p><ul><li>通过密码连接，这个一般由服务器产商提供；</li><li>通过秘钥-公钥配对连接，这个需要自己在服务器和客户端(本地电脑)进行设置。</li></ul><p>参考视频：</p><ol><li><a href="https://www.bilibili.com/video/BV1Ld4y1M7EV/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=41769b252ab81d02e47e5775242eda15">[纯干货] 快速配置ssh远程开发 让VScode远程开发得心应手</a></li></ol><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h2><p>参考<a href="https://blog.csdn.net/thesat/article/details/122657537">hexo搭建博客</a>，这里详细讲了如何配置GitHub的shh密钥。<br>最后可运行<code>ssh -T git@github.com</code>,看是否出现<code>Hi Hushuangjun! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>,出现的话就说明配置成功了。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol><li>基本版本控制<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init  //初始化文件夹</span><br><span class="line"></span><br><span class="line">git add . //添加目前文件路径下所有文件到暂存区</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;版本号(根据修改内容填写)&quot;</span>  //提交</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>GitHub仓库(假设有一个test.git仓库)同步<ol><li>先在GitHub上创建仓库(test.git).</li><li>复制仓库地址.<code>https://github.com/Hushuangjun/test.git</code><br>然后在本地版本控制的文件夹下运行如下代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Hushuangjun/test.git  //将本地文件夹与远程服务器中仓库关联</span><br><span class="line"></span><br><span class="line">git push -u origin main //推送到远程仓库，其中main是要推送的分支。</span><br></pre></td></tr></table></figure>如果你这个仓库是<code>fork</code>别人的，那么最好还需跟上游仓库(也就是原有仓库)建立连接，以便后续方便从上游仓库获取更新和为上游仓库的变更创建本地分支(做一个贡献者).<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https:<span class="regexp">//gi</span>thub.com<span class="regexp">/真正作者的名字/</span>test.git</span><br></pre></td></tr></table></figure><h2 id="Git配置代理"><a href="#Git配置代理" class="headerlink" title="Git配置代理"></a>Git配置代理</h2>参考：<a href="https://ericclose.github.io/git-proxy-config.html#%E5%AE%9E%E4%BE%8B-1">一文让你了解如何为 Git 设置代理</a></li></ol></li></ol><h2 id="Git命令集合"><a href="#Git命令集合" class="headerlink" title="Git命令集合"></a>Git命令集合</h2><p><img src="//husj0711.top/2024/OldBlogs/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/Git命令集合.png" alt="Git常用命令"></p><h1 id="VSCcode-断点调试"><a href="#VSCcode-断点调试" class="headerlink" title="VSCcode-断点调试"></a>VSCcode-断点调试</h1><p>当在 Visual Studio Code (VSCode) 中进行断点调试时，通常会使用一系列调试控制命令来控制代码的执行。以下是一些常见的断点调试控制命令以及它们之间的区别：</p><ol><li><strong>继续：</strong><ul><li>从当前断点继续执行代码直到下一个断点或程序结束。如果没有设置断点，将一直执行到程序结束。</li></ul></li><li><strong>逐过程：</strong><ul><li>点一下运行当前行代码，并把高亮标志移动到下一行。如果当前行是一个函数，运行整个函数，而不会进入函数内部。</li></ul></li><li><strong>单步调试：</strong><ul><li>逐行执行代码，如果当前行包含函数调用，则进入该函数内部。</li></ul></li><li><strong>单步跳出：</strong><ul><li>执行完当前函数的剩余部分，并停在调用该函数的地方。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-迷路的指针</title>
      <link href="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/"/>
      <url>/2024/OldBlogs/%E7%A0%B4%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="变量与运算符"><a href="#变量与运算符" class="headerlink" title="变量与运算符"></a>变量与运算符</h2><ol><li>getchar()函数<ol><li><strong>只能从键盘缓冲区接收字符，一次只能接收一个字符</strong>。如果之前有<code>scanf(&quot;%c&quot;,&amp;str);</code>类似语句，回车键<code>\n</code>也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。</li><li>如果之前没有用scanf()接收过字符,那么使用getchar()函数时，需要先键入字符，<strong>按enter键后</strong>，键入的字符(串)进入缓冲区，然后getchar会从中取一个字符(按输入的顺序)，以后每次调用getchar()都会从缓冲区接收一个字符，直至缓冲区字符用完，再重复以上步骤。</li><li>getchar()函数的返回值也不是字符而是一个整型.(读取成功时就返回该字符的ASCⅡ值，失败时就返回一个-1。)</li><li>典型例题：加密电文，所有大小写英文字母＋4(ASCII码) 循环，其余字符不变。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; (str=getchar()) != <span class="string">&#x27;\n&#x27;</span> ; )&#123;</span><br><span class="line">        <span class="keyword">if</span> (str&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;A&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>scanf()函数</p><ol><li><p>scanf()函数返回值是是成功读取并赋值的参数的数量。<br>scanf()函数返回值分为3种：<br>(1). 返回正整数。表示正确输入参数的个数。<br>(2). 返回整数0。表示用户的输入不匹配，无法正确输入任何值。<br>(3). 返回-1。表示输入流已经结束。在Windows下，用户按下CTRL+Z（会看到一个^Z字符）再按下回车（可能需要重复多次），就表示输入结束；Linux/Unix下使用CTRL+D表示输入结束。</p><p>参考如下例题：<a href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>.<br>上述例题的两种解法：(链接中已给出一种，下给出另一种)    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,d[<span class="number">3</span>];</span><br><span class="line">   <span class="type">int</span> judge = <span class="number">1</span>,count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; judge;)&#123; <span class="comment">//判断条件是judge不为0.</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[j]);</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">               judge = <span class="number">0</span>; <span class="comment">//遇到换行符即表示输入结束。</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (j == <span class="number">3</span> &amp;&amp; (d[<span class="number">0</span>] + d[<span class="number">1</span>] == d[<span class="number">2</span>]))&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>scanf()也是从键盘缓冲区得到输入，一般来说，遇到换行符<code>\n</code>就表示输入项结束了，但在上述例子<a href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>中，scanf由于一次性需要接收三个参数，此时换行符<code>\n</code>就不起作用了，需要手动敲<code>ctrl + z</code>再按回车。<strong>windows上，<code>ctrl + z</code>就表示输入项的结束</strong>。具体可参考<a href="https://blog.csdn.net/i6223671/article/details/89041492">详解输入输出流结束标志ctrl+z和EOF</a>.</li></ol></li><li>逗号表达式<br>逗号表达式一般形式为: <code>expr1, expr2, expr3,...,exprn</code>.<br>逗号表达式从左到右依次求值，每个表达式的值被忽略，除了最后一个表达式。逗号表达式的值就是最后一个表达式的值。   </li><li><p>运算符优先级及结合性<br>结论：<strong>先计算优先级大的，相同优先级再根据结合性计算</strong>。<br><div align="center"><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/运算符优先级及结合性.jpg" width="90%"></div><br>观察如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">5</span>, y;</span><br><span class="line"></span><br><span class="line">   y = <span class="number">2</span> * x++;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;x = %d&quot;</span>,x);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;y = %d&quot;</span>,y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是:</p><blockquote><p>x = 6; y = 10;</p></blockquote><p>于是疑问出现了，自增运算符<code>++</code>优先级不是大于乘<code>*</code>吗？不是先自增再乘嘛，这样<code>y = 2*6 = 12</code>.<br>其实：程序确实先进行自增运算符，但<code>++x和x++</code>返回的结果是不同的，然后再赋值给y。<strong>特别是x++，它的返回值就是x，而++x的返回值是x + 1</strong>, 所以造成一种假象，以为先进行了乘法运算。<br>小试牛刀：  </p><blockquote><p>关于<code>str = &#39;!&#39;; 48 &lt;= str &lt;= 57</code>为啥总是得到1？</p></blockquote><p>因为<code>&lt;=</code>的结合性是自左向右，故先会计算<code>48 &lt;= str</code>,此时str = ‘!’,ASCII值是33，故返回值是0.再计算<code>0 &lt;= 57</code>,返回值是1.由此可以看出学了python之后，再学C感觉步骤很啰嗦。但正是因为步骤啰嗦（分类齐全，条理清晰），故C速度很快。</p></li></ol><h2 id="选择结构程序设计"><a href="#选择结构程序设计" class="headerlink" title="选择结构程序设计"></a>选择结构程序设计</h2><ol><li>注意<code>if - else if - else</code>，按顺序判断，只要其中一个条件为真，剩下的就不会执行！<br>如果<strong>没有大括号就遵循就近原则</strong>，所以写的时候尽量带上大括号。例如:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>最后结果什么也不会输出！因为其相当于<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>switch</code>选择语句：注意表达式A的值必须为整型数据（当然包括字符型），而a、b…必须是常量或者常量表达式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式A) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> a:  表达式<span class="number">1</span>  ; <span class="keyword">break</span>;  <span class="comment">// 必须加上break，否则后续case会一直执行，直到break或者全部读完。</span></span><br><span class="line">   <span class="keyword">case</span> b:  表达式<span class="number">2</span>  ; <span class="keyword">break</span>;  <span class="comment">// 表达式A的值为a\b..时，就执行对应语句。</span></span><br><span class="line">   <span class="keyword">case</span> c: &#123; <span class="comment">// 也可以写成这样。</span></span><br><span class="line">     表达式<span class="number">1</span>;</span><br><span class="line">     表达式<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">default</span>:  表达式n ; <span class="keyword">break</span>;  <span class="comment">// 可以不用break,反正都结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>C语言中唯一一个三目运算符：条件运算符(<code>? :</code>)，对应表达式就是条件表达式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? a:b</span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line">c = a &gt; b ? a:b ;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">   c = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   c = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构程序设计"><a href="#循环结构程序设计" class="headerlink" title="循环结构程序设计"></a>循环结构程序设计</h2></li><li><code>while</code>循环：表达式为真，进入循环，直至表达式为假或者<code>break;</code>跳出循环.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>do while</code>循环：特别注意while后面还有个分号<code>;</code>.  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>；</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式) ;  </span><br></pre></td></tr></table></figure></li><li><code>for</code>循环:其中表达式1和3可以为<strong>逗号表达式</strong>，表达式2是判断条件，为真的话继续。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">表达式<span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">   表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义及初始化"><a href="#数组定义及初始化" class="headerlink" title="数组定义及初始化"></a>数组定义及初始化</h3><p>一维数组定义：(二维数组同理)</p><blockquote><p>类型符  数组名[常量表达式]</p></blockquote><p>特别注意是<strong>常量表达式</strong>，不能是<strong>变量</strong>。<br>但是！C99推出了<strong>变长数组</strong>(Variable Length Array，VLA),它允许在运行时动态地定义数组的长度，但一旦定义，在其生命周期内大小不可改变。<br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of rows: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rows);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of columns: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cols);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> matrix[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时，值得注意的是，<strong>VLA不允许在定义的时候初始化</strong>！<br>例如<code>int matrix[rows][cols] = &#123;0&#125;;</code>，编译器会报错。</p><hr><p>二维数组是一维数组线性拓展得到的，也是以线性的方式存储的。<br>数组名的值数组第一个元素的地址，相当于是一个常量，是不能被赋值的。因此下列数组初始化是错误的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="字符串输入与输出"><a href="#字符串输入与输出" class="headerlink" title="字符串输入与输出"></a>字符串输入与输出</h3><p>   如何直接输出字符串？或者输入字符串?<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出, str是已定义的字符串数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">put(str);  <span class="comment">// 特别注意put不能输出多个字符串,而printf()可以。</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//由于str的值就是数组第一个元素的地址，故不需要取值符`&amp;`.同时，输入的字符串大小应不大于定义的字符数组的大小。</span></span><br><span class="line">get(str); <span class="comment">//同理，一次只能接收一个字符串数组。</span></span><br></pre></td></tr></table></figure></p><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">作用</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">puts(str)</td><td style="text-align:center">输出<strong>单个</strong>字符串</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">gets(str)</td><td style="text-align:center">输入<strong>单个</strong>字符串</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">strlen(str)</td><td style="text-align:center">测量字符串的长度</td><td style="text-align:center">返回字符串的长度(不包括<code>\0</code>)</td></tr><tr><td style="text-align:center"><strong>sizeof(str)</strong></td><td style="text-align:center">测量字符串的内存大小</td><td style="text-align:center">返回字符串的内存大小(注意，如果字符串没规定大小，如<code>char str[] = &quot;string&quot;;</code>,则返回值包括<code>\0</code>,如果规定大小了，则返回的值该大小所占字节。)</td></tr><tr><td style="text-align:center">补充：sizeof(array)</td><td style="text-align:center">测量其他类型数组的内存大小</td><td style="text-align:center">返回其他类型数组的内存大小(此时并没有<code>\0</code>的烦恼了)</td></tr><tr><td style="text-align:center">strcat(str1, str2)</td><td style="text-align:center">将<strong>字符串2</strong>接到<strong>字符串1</strong>后面</td><td style="text-align:center">返回的是字符串1的地址</td></tr><tr><td style="text-align:center">strcpy(str1, str2)</td><td style="text-align:center">将字符串2(包括<code>\0</code>)复制到字符串1中</td><td style="text-align:center">返回的是字符串1的地址</td></tr><tr><td style="text-align:center">strncpy(str1, str2, n)</td><td style="text-align:center">将字符串2前n个字符复制到字符串1中</td><td style="text-align:center">返回的是字符串1的地址</td></tr><tr><td style="text-align:center">strlwr(str)</td><td style="text-align:center">将字符串中大小写字母变成<strong>小写字母</strong></td><td style="text-align:center">不返回任何值，对于字符串是原位修改</td></tr><tr><td style="text-align:center">strupr(str)</td><td style="text-align:center">将字符串中大小写字母变成<strong>大写字母</strong></td><td style="text-align:center">不返回任何值，对于字符串是原位修改</td></tr><tr><td style="text-align:center">strcmp(str1, str2)</td><td style="text-align:center">依次比较str1和str2中字符的大小，按照ASCII码比较</td><td style="text-align:center">str1==str2,则返回0；str1 &gt; str2,则返回一个正整数;str1 &lt; str2，则返回一个负整数.</td></tr></tbody></table></div><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针与指针变量"><a href="#指针与指针变量" class="headerlink" title="指针与指针变量"></a>指针与指针变量</h3><p>指针变量也是一个变量，占用的字节大小取决于其<strong>存储的内存地址</strong>的大小，而常说的指针应该是指针变量，其值是“内存地址”（指针）。<br><strong>需要说明的是</strong>：后续所讲<code>指针</code>多指<code>指针变量</code>,例如p指向变量a,完整的说法是：p的值是变量a的地址。</p><p>前提:int x = 10, *y; y = &x;<br><strong>重点：可以认为*y == x。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针变量，&amp;为取地址运算符</span></span><br><span class="line"><span class="type">char</span> *pa = &amp;a;   <span class="comment">//用char是因为指针变量所储存的内存地址所对应的数据类型是char.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pa); <span class="comment">//打印内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pa); <span class="comment">//打印变量a的值，这里*是取值运算符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也即：</span></span><br><span class="line">*(&amp;a) = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>下面以小甲鱼的一道课后习题来介绍：<br>Q:请问下边代码执行后，打印机的结果是什么？另外，*b 是左值（l-value）还是右值（r-value）？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">110</span>;</span><br><span class="line">   <span class="type">int</span> *b = &amp;a;</span><br><span class="line">   *b = *b - <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>打印结果是 a = 10.</p></blockquote><p>第一个问题：定义指针变量 b 的时候，存放的是变量 a 的地址。在此之后，*b 即对变量 a 的间接访问（通过地址访问 a 变量）。所以 *b = *b - 10; 相当于 a = a - 10; 也就是说，<strong>通过指针对一个变量间接访问，你可以理解为把它作为那个变量本身使唤</strong>（即 *b == a）.</p><p>第二个问题：<strong>指针变量 b 既是左值，也是右值</strong>。</p><p>此外，关于取址符（&amp;）还有个疑问：一般来说取址符作用对象是左值（lvalue），而数组名不是左值，为啥取址符还可以作用于数组名？<br>A：其实左值下面有个子集——可修改的左值，位于等式左边必须要求可修改的左值！由此可见，之前一直存在认知误区，其实数组名是左值，只是不可修改罢了。于是有以下结论：</p><ul><li>取址符作用于左值，数组名是左值（不可修改的左值），故可将取址符作用于数组名！！！</li></ul><p>参考： <a href="https://blog.csdn.net/imred/article/details/45441457">数组和指针的区别</a></p><h3 id="一维数组与指针的关系"><a href="#一维数组与指针的关系" class="headerlink" title="一维数组与指针的关系"></a>一维数组与指针的关系</h3><p>(不特别说明，数组均指一维数组)<br><strong>数组名==指针变量</strong>，数组名储藏着数组第一个元素的地址，对于<strong>字符数据类型</strong>，可以直接用指针创建数组，下面代码演示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = <span class="string">&quot;OUC&quot;</span>;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]); <span class="comment">//此处相当于是 a[i] = *(a+i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然而对于int等类型，通过指针创建是行不通，究其原因，是因为字符数组就是第一个字符的地址（指针变量），且字符数组名和其他数组名一样，也是指针变量，指向数组第一个元素。</p><blockquote><p>char str[] = “string”;<br>上述str和”string”都可以当作指针变量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*(<span class="string">&quot;sting&quot;</span>)); <span class="comment">//会输出&#x27;s&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过指针访问数组</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d, *(p+1) = %d.\n&quot;</span>,*p, *(p+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果就是:</p><blockquote><p>*p = 1, *(p+1) = 2.</p></blockquote><p>这就是通过<strong>指针间接访问数组的办法，区别于下标直接访问法</strong>。<br>此处要注意的是，只有当指针指向数组元素时，指针算术运算才有意义，否则就会给未用地址乱赋值，就会报错(Segmetation default)。<br>既然数组名也是一个指针变量，那么同理也用数组名进行访问，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d, *(a+1) = %d.\n&quot;</span>,*a, *(a+<span class="number">1</span>));  <span class="comment">//这个为后续指针数组做下铺垫，例如int (*ptr)[5] = &amp;a;  这里ptr是一个指针变量，存着数组a的地址，*ptr就是数组a，也就代表着数组第一个元素的地址。从而有</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int (*ptr)[5] = &amp;a;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for (i = 0; i&lt;5; i++)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d&quot;,*(*ptr+i));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>⭐⭐⭐同时又可以发现：<strong>指针所指向的数据类型决定指针的跨度。</strong></p><h3 id="指针与数组的区别"><a href="#指针与数组的区别" class="headerlink" title="指针与数组的区别"></a>指针与数组的区别</h3><p>指针变量是左值(lvalue)，可以修改的；而数组名是地址常量，不可以修改，故不是左值。<br>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> str[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *target = str;  </span><br><span class="line">    <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*target++ != <span class="number">3</span>)  <span class="comment">//此处必须用指针变量，不能用数组名。</span></span><br><span class="line">    <span class="comment">// 这里*target++是啥呢？ 由于增运算符(变量++)的优先级大于取值运算符(*)，故先进行target++,再取值*，相当于*(target++)。</span></span><br><span class="line">    <span class="comment">//同时，还需注意，自增运算符在变量后面，故取值符(*)取用的是未自增前的值。</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总共有%d个数字\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>小甲鱼作业S1E22第2题</strong>：</p><blockquote><p>请问 str[20] 是否可以写成 20[str]？<br>A: C 语言中，<code>a[b]</code> 被解释为 <code>*(a + b)</code>,故两者等价。</p></blockquote><h3 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h3><p>指针数组是指数组元素全为指针的数组；数组指针是一个指针，它指向的是一个数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区分下列哪个是指针数组，哪个是数组指针</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">//int (*p)[5]就相当于int a[5]，a就是数组地址！！！ (区别于数组首地址，后面会讲到)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ ]优先级大于*；虽然[]和()优先级一样，但结合性是从左到右，故第一个是指针数组，第二个是数组指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>指针数组的一个用途：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *p[<span class="number">3</span>] = &#123;   <span class="comment">//由于指针数组存放的都是指针，而数组名就是指针变量。</span></span><br><span class="line">        <span class="string">&quot;让编程改变世界&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Just do it!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;一切皆有可能&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[i]);  <span class="comment">// %s是通过字符串首地址输出字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关于数组指针还有一个坑，数组指针指向的是一个数组，而我们之前常用<code>int *p = temp;</code>(此处temp是一个已定义的整型数组)来将<code>指针指向数组</code>,但实际上，<strong>指针只是指向了数组第一个元素的地址</strong>。现在我们要想数组指针指向整个数组，需使用<code>int (*p)[5] = &amp;temp</code>;这里<code>&amp;temp</code>相当于将整个数组看作一个整体来看待的。(必须清楚的是，数组第一个元素的地址跟整个数组的地址是相同的。)举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// int (*p)[5] = temp;  //输出也可以，因为把数组当作整体给出地址还是数组首地址，但编译器会提醒。</span></span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*p + i)); </span><br><span class="line">        <span class="comment">// p是一个指向数组(并非指向数组第一个元素)的指针，*p就是取出该指针对应的内容，也就是数组temp，即*p=temp，而temp又是数组第一个元素的地址，可以当作指针，并进行指针运算。</span></span><br><span class="line">        <span class="comment">//注意，此时*(*p) = *(temp) = 数组temp的第一个元素.有点嵌套指针的意味了！</span></span><br><span class="line">        <span class="comment">//于是，上述输出也可写成: printf(&quot;%d\n&quot;,(*p)[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>小甲鱼课后作业：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">5</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;FishC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Five&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Star&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Good&quot;</span>,</span><br><span class="line">        <span class="string">&quot;WoW&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> *(*p)[<span class="number">5</span>] = &amp;<span class="built_in">array</span>;  <span class="comment">//定义指向包含5个指针的数组的指针，也就是说这个数组的类型是字符指针类型，故定义相同类型(char *)的数组指针</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; *(*(*p+i)+j) != <span class="string">&#x27;\0&#x27;</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,*(*(*p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处<code>p</code><strong>实际上是指向包含5个指针的数组，最好写成char<em> (</em>p)[5] = array;</strong></p><h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>观察下述代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array is %p\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array +1 is %p\n&quot;</span>,<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>输出结果是：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array is 0xbfc34320<span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>+1 is 0xbfc34334</span><br></pre></td></tr></table></figure><br>由此得出，二维数组的数组名指向包含5个元素的数组(也就是第一行元素所构成的数组)，<strong>二维数组名实际上就是数组指针</strong>！！！<br>同时也可明白，<code>array + 1</code>则指向第二行构成的数组，即此处的<code>array +1</code>相当于前述的<code>p</code>.   </p><p>二维数组名也可赋值给数组指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>] = <span class="built_in">array</span>; <span class="comment">// p指向第一行元素构成的数组</span></span><br><span class="line">    <span class="type">int</span> (*n)[<span class="number">3</span>] = <span class="built_in">array</span> + <span class="number">1</span>;<span class="comment">// n指向第二行元素构成的数组</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*p)[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*n)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p); <span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,<span class="built_in">array</span>);<span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;(*<span class="built_in">array</span>)); <span class="comment">// 输出第一行元素构成的数组的地址。(注意，并非数组的第一个元素，尽管两者数值上相等。)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p); <span class="comment">//输出第一行元素构成的数组的第一个元素的地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**(p+<span class="number">1</span>));<span class="comment">// p是第一行元素构成的数组的地址，(p+1)则是第二行元素构成的数组的地址。</span></span><br><span class="line">    <span class="comment">//因为二维数组在内存中也是线性存储的，p+1表示指针往后移3*4=12个字节，也就是第二行元素构成的数组的地址。</span></span><br><span class="line">    <span class="comment">//即p+1指向第二行元素构成的数组。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="void指针与NULL指针"><a href="#void指针与NULL指针" class="headerlink" title="void指针与NULL指针"></a>void指针与NULL指针</h3><p>void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，<strong>任何类型的指针都可以赋值给void指针。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;num;</span><br><span class="line">    <span class="type">char</span> *n = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ye;</span><br><span class="line"></span><br><span class="line">    ye = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ye:%p p:%p\n&quot;</span>,ye,p);</span><br><span class="line">    ye = n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ye:%p n:%p\n&quot;</span>,ye,n); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是，又引出几个问题：</p><ol><li>void指针如何取值？编译器怎么知道？<ul><li>所以，强制转换符<code>(强制转换类型 *)</code>又出现了。</li></ul></li><li>对于 void指针 <code>p</code>，<code>p + 1</code>移动多少个字节？<ul><li>由于编译器不知道其指向的数据类型，故只移动一个字节。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ye:%d\n&quot;</span>,*((<span class="type">int</span> *)ye));  </span><br></pre></td></tr></table></figure>NULL指针，即空指针，不指向任何一个地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空指针的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NULL ((void *)0)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">//定义空指针，解引用(取值)的话程序会报错。</span></span><br><span class="line"><span class="comment">//也可以写成 int *p = (void *)0 ;</span></span><br><span class="line"><span class="type">int</span> *m; <span class="comment">//还未初始化，称为野指针。</span></span><br></pre></td></tr></table></figure>注意，是NULL而不是NUL（在ASCII表中）。</li></ul><ol><li>NULL用于指针和对象，表示控制，指向一个不被使用的地址。</li><li>NUL(‘\0’)表示字符串的结尾。</li></ol></li></ol><p>小甲鱼S1E24：指针和二维数组第5题出现了<code>(int (*)[3])</code>强制类型转换符。具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">array</span>[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> (*p)[<span class="number">3</span>] = (<span class="type">int</span> (*)[<span class="number">3</span>])&amp;<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>(int (*)[3])&amp;array</code>等号右边强制将 array 这个一位数组重新划分成3*3的二维数组，p等于二维数组。这与前面第6条所说：<code>二维数组名就是数组指针</code>相呼应。小甲鱼的答案有点问题，p并不是指向二维数组，p就是二维数组名，指向二维数组第一行元素构成的数组。</p><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;  <span class="comment">//此即指向指针的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证是否指向指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n*pp = %p&quot;</span>,p,*pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那指向指针的指针有啥用呢？观察如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cBooks[] = &#123;</span><br><span class="line">        <span class="string">&quot;C primer plus&quot;</span>,</span><br><span class="line">        <span class="string">&quot;带你学C带你飞&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C与指针&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> **charm;</span><br><span class="line"></span><br><span class="line">    charm = &amp;cBooks[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,*charm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由此可以看出，指向指针的指针至少有以下两个好处：</p><ul><li>避免重复分配内存；</li><li>只需对一处进行修改.</li></ul><h3 id="指向指针的指针与二维数组"><a href="#指向指针的指针与二维数组" class="headerlink" title="指向指针的指针与二维数组"></a>指向指针的指针与二维数组</h3><p>观察如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> **p = <span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(*(p+i)+j));   <span class="comment">//对应着case one</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d&quot;,*(*(array+i)+j));  //对应case two</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Case one:</p><blockquote><p>由于p是一个指针，故p+i就是指针移动<code>i</code>个<code>int</code>数据类型所占的字节。例如，i = 1,则p+1就是第一行元素构成数组的地址+4，如果再取值<code>*</code>,由于找不到对应的内容(因为无论是整个数组地址还是数组第一个元素的地址，数值上都等于数组第一个元素的地址，且二维数组的行并不一定在内存中是连续存储的。）因此，使用错误的指针类型可能导致对内存的错误访问，从而触发段错误<code>sgementation default</code>。</p></blockquote><p>Case two:</p><blockquote><p>array可行，因为array本身可看作数组指针，array+1就是移向下一行。</p></blockquote><p>因此，要想正确输出，需将上述代码改为如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = <span class="built_in">array</span>;  <span class="comment">//利用数组指针</span></span><br></pre></td></tr></table></figure><br>这里值得注意的是：</p><ol><li>因为array实际上是第一行元素的构成的数组的地址，<code>[num]</code>中<code>num</code>必须要和该数组元素个数相等。p指向一个4个元素的数组，则<code>p + 1</code>移动<code>sizeof(int) * 4</code>个字节。而如果是<code>*p</code>,此时<code>*p</code>是指向第一行元素的构成的数组的第一个元素，此时<code>*p + 1</code>移动<code>sizeof(int)</code>个字节。</li><li>由上可见，<strong>正如第2条最后所说，指针所指向的数据类型决定指针的跨度</strong>。</li></ol><p>小试牛刀：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;How are you?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;I&#x27;m fine, thanks&quot;</span>,</span><br><span class="line">        <span class="string">&quot;and you?&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span>* (*p)[<span class="number">4</span>]  = &amp;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(*p)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Ps:B站这一节课有弹幕指出：可以写成<code>(*p)[3][4] = &amp;array</code>,这个其实相当于定义了一个指向二维数组的指针。代码可修改如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>][<span class="number">4</span>] = &amp;<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,*(*(*p+i)+j)); <span class="comment">//由于p指向整个二维数组，故*p就是二维数组，指向二维数组第一行元素构成的数组，这样也就弱化为指向数组的指针了，同前述第6节。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h3><p>常量：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520</span>, <span class="string">&#x27;A&#x27;</span>, <span class="params">...</span></span><br></pre></td></tr></table></figure><br>常变量:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">//这样使得a只能读，不能修改，相当于常量，但不是常量.</span></span><br></pre></td></tr></table></figure><br>定义指向常量的指针(<strong>区别于后续所讲常量指针</strong>):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;num;  <span class="comment">//定义指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针指向的值，则会发生错误</span></span><br><span class="line">*p = <span class="number">1250</span>;</span><br><span class="line"><span class="comment">//error: assignment of read-only location &#x27;*p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针的值，这是允许的，相当于该指针不指向常量num.</span></span><br><span class="line"><span class="type">int</span> cnum = <span class="number">250</span>;</span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//编译通过。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时如果改变p指向的值，则报错：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//但是，我们如果修改cnum的值：</span></span><br><span class="line">cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功。</span></span><br></pre></td></tr></table></figure><br>指向常量的指针-总结：</p><ul><li>指针可以修改为指向不同的常量</li><li>指针可以修改为指向不同的变量</li><li>可以通过解引用来读取指针指向的数据</li><li>不可以通过解引用修改指针指向的数据</li></ul><p>那什么是常量指针呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num; <span class="comment">//定义指向非常量的常量指针</span></span><br></pre></td></tr></table></figure><br>特性：</p><ul><li>指针本身值不可改变，指向的值可修改。</li><li><strong>典型例子就是数组名</strong>。</li></ul><p>定义指向非常量的常量指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指向的值：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改本身值：</span></span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//报错：error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><br>如果定义一个指向常量的常量指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;cnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此时既修改指针的值，又修改指针所指向的值，则会报两个错：</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line">p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error:error: assignment of read-only location &#x27;*p&#x27;;</span></span><br><span class="line"><span class="comment">// error:error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><br>可以看出其特点：</p><ul><li>指针本身值不可改变，指向的值也不可修改。</li></ul><p>但有趣的一点是，如果你定义了指向常量的常量指针，但接受的地址不是常量，还是可以通过改变该非常量来修改指针所指向的值的。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line">num = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出111.</span></span><br></pre></td></tr></table></figure><br>又进一步引出：指向 “指向常量的常量指针” 的指针。<br>看到名字别害怕，<strong>去掉定语，也即指向指针的指针</strong>。</p><blockquote><p>要记住:一般来说，<strong>要指向 “常量指针”，自己也必须是指向常量的指针。</strong><br>但如果自己不是指向常量的常量指针也可以的，不过会有<code>warning</code>, 后面详细介绍了<code>const的约束对象</code>，理解将会更加深刻。</p></blockquote><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **  pp = &amp;p; <span class="comment">//定义指向 “常量指针” 的指针</span></span><br><span class="line"><span class="comment">//上行代码也可以写成（但不推荐）：</span></span><br><span class="line"><span class="comment">//int **p = &amp;p;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证pp指向p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pp = %p, &amp;p = %p\n&quot;</span>,pp,&amp;p);</span><br><span class="line"><span class="comment">//验证*pp == p == &amp;num</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pp = %p, p = %p,&amp;num = %p\n&quot;</span>,*pp,p,&amp;num);</span><br><span class="line"><span class="comment">//验证**pp == *p == num;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**pp = %d, *p = %d, num = %d\n&quot;</span>,**pp,p,num);</span><br></pre></td></tr></table></figure></p><p>小甲鱼S1E27：常量和指针， 关于<code>const的约束对象</code>：<br>请问在下边声明中，const 限制的是 q、*q 还是 **q？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> *q = &amp;p;</span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>答： 第一个const限制<code>**q</code>(即指针的两次解引用，可以理解为num,但不是num.因为num如果是<code>int num = 250</code>,那么num还是可以修改的，而<code>**q</code>则是不可以的。),第二个const限制<code>*q</code>(同上述理);</p><p>记住一点：<strong>const 永远限制紧随着它的标识符</strong>。那么，如果想要使用 const 同时限制 q、*q 和 **q，应该怎么做？</p><blockquote><p>const int * const * const p; 或者int const * const * const p; 因为<code>const *p</code>等价于 <code>int const *p</code>; 但一般为了可读性，就不写成<code>int const *p</code>,但<code>int const *p</code>更能体现这句话—-const 永远限制紧随着它的标识符.</p></blockquote><p>于是又有人问了，<code>const int const **p</code>; 限制了啥？</p><blockquote><p>其实只限制了<code>**p</code>.</p></blockquote><p>重点：限制了谁谁就变可读了，不能修改（也就不是可修改的左值了）。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数初体验"><a href="#函数初体验" class="headerlink" title="函数初体验"></a>函数初体验</h3><ol><li>C语言程序编译的时候是从上至下，执行的时候是从main()函数开始的。</li><li>void函数不返回任何值，因此不需要加<code>return xxx  ;</code></li><li>养成好习惯：要使用某个函数<code>int func()</code>，先进行声明<code>int func();</code>,千万别丢了分号<code>;</code>.<br>函数声明时，既可带上参数名，也可不带。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>如果定义一个与标准库函数重名的函数，会怎样？<ul><li>重新定义的同名函数会覆盖标准库函数（前提是两者的声明一致，包括返回值和参数类型、个数一致）。</li></ul></li></ol><h3 id="参数和指针"><a href="#参数和指针" class="headerlink" title="参数和指针"></a>参数和指针</h3><ol><li><p>传值和传址<br>观察下列两个代码：<br><strong>传值：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line">    swap(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><blockquote><p>交换前: x = 3, y = 5<br>交换后: x = 3, y = 5</p></blockquote><p><strong>传址：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line">    swap(&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><blockquote><p>交换前: x = 3, y = 5<br>交换后: x = 5, y = 3</p></blockquote></li></ol><p>   为啥结果会不同呢？<br>   因为函数swap(int x, int y)会给x,y单独在内存中找两段储存空间(可理解为局部变量)，<strong>存放传进来的值</strong>，对原来地址上的值无影响。如果传给函数的本就是地址，则函数内部调用时，就是直接对原来地址上的值进行操作。</p><ol><li>传数组<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[])</span>; <span class="comment">//由于传递数组本质是传递数组第一个元素地址，此处可以不写数组元素个数。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof b: %d\n&quot;</span>,<span class="keyword">sizeof</span>(b)); <span class="comment">//由于传递的是一个地址，也就是指针，取决于操作系统。我的操作系统是64位，故返回8。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof a: %d\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    get_array(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p>可变参数<br>首先需要调用<code>stdarg.h</code>头文件，具体实现原理可见<a href="https://www.cnblogs.com/clover-toeic/p/3736748.html">可变参数详解</a>，常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">VarArgFunc</span><span class="params">(<span class="type">int</span> dwFixedArg, ...)</span>&#123; <span class="comment">//以固定参数的地址为起点依次确定各变参的内存起始地址</span></span><br><span class="line"></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;  <span class="comment">//定义va_list类型的指针pArgs，用于存储参数地址</span></span><br><span class="line"></span><br><span class="line">    va_start(pArgs, dwFixedArg); <span class="comment">//初始化pArgs指针，使其指向第一个可变参数。该宏第二个参数是变参列表的前一个参数，即最后一个固定参数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dwVarArg = va_arg(pArgs, <span class="type">int</span>); <span class="comment">//该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若函数有多个可变参数，则依次调用va_arg宏获取各个变参</span></span><br><span class="line"></span><br><span class="line">    va_end(pArgs);  <span class="comment">//将指针pArgs置为无效，结束变参的获取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Code Block using variable arguments */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_arg</span><span class="params">(<span class="type">int</span> n, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func_arg</span><span class="params">(<span class="type">int</span> n, ...)</span>&#123;</span><br><span class="line">    va_list pargs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pargs,n);</span><br><span class="line">    <span class="type">int</span> i = va_arg(pargs, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    func_arg(<span class="number">10</span>);<span class="comment">//打印固定参数i堆栈上方一个内容(垃圾值)</span></span><br><span class="line">    func_arg(<span class="number">10</span>,<span class="number">5</span>);<span class="comment">//打印固定参数i堆栈上方一个内容(5)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 原理图如下所示：</p><div align="center"><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/可变参数堆栈.png" width="80%"></div><p><strong>小试牛刀</strong>：尝试实现sum()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,sum = <span class="number">0</span>;</span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pArgs,n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">        sum += va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(pArgs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>勇攀高峰</strong>：尝试自己模拟实现 printf 格式化输出的基本功能，基本要求如下：</p><ul><li>输出第一个参数中除了格式化占位符外的所有字符</li><li>实现 %d 的格式化输出</li><li>实现 %c 的格式化输出</li><li>实现 %s 的格式化输出</li><li>实现 myprintf 函数返回打印了多少字符</li><li><p><strong>全程仅能使用 putchar 唯一一个标准库函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span>* str,...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printstr</span><span class="params">(<span class="type">char</span>* str)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printstr</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i++]);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dec = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = num;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">9</span>)&#123;</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">        dec *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dec &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(num/dec + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        num %= dec ;</span><br><span class="line">        dec /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span>* str,...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> carg;</span><br><span class="line">    <span class="type">char</span> *sarg ;</span><br><span class="line">    <span class="type">int</span> darg;</span><br><span class="line"></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pArgs,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str[i++]);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (str[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:&#123;</span><br><span class="line">                    sarg = va_arg(pArgs,<span class="type">char</span>*);</span><br><span class="line">                    num += printstr(sarg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:&#123;</span><br><span class="line">                    carg = va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">                    <span class="built_in">putchar</span>(carg);</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">                    darg = va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">                    num += printint(darg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(pArgs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = myprintf(<span class="string">&quot;Hello %s\n&quot;</span>, <span class="string">&quot;FishC&quot;</span>);</span><br><span class="line">    myprintf(<span class="string">&quot;共打印了%d个字符(包含\\n)\n&quot;</span>, i);</span><br><span class="line">    i = myprintf(<span class="string">&quot;int: %d, char: %c\n&quot;</span>, <span class="number">-520</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    myprintf(<span class="string">&quot;共打印了%d个字符(包含\\n)\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="headerlink" title="指针函数与函数指针"></a>指针函数与函数指针</h3><ol><li>指针函数<br>定义：使用<strong>指针变量作为函数的返回值</strong>的函数，就是指针函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">pointer</span><span class="params">()</span>; <span class="comment">//写成 char* pointer();可能更好理解，但遵循一般习惯，就这样吧。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">pointer</span><span class="params">()</span>&#123;</span><br><span class="line"> ...;</span><br><span class="line"> <span class="keyword">return</span> 字符指针;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>需要特别注意的是：<strong>不要返回局部变量的指针！！！</strong><br>举例如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_word</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_word</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要写成下面这样，因为函数一结束，所有变量值会被清理掉，虽然返回了变量的地址，但该地址上啥值也没有。</span></span><br><span class="line"><span class="comment">// char *get_word(char c)&#123;</span></span><br><span class="line"><span class="comment">//     char str1[] = &quot;Apple&quot;;</span></span><br><span class="line"><span class="comment">//     char str2[] = &quot;Banana&quot;;</span></span><br><span class="line"><span class="comment">//     char str3[] = &quot;Cat&quot;;</span></span><br><span class="line"><span class="comment">//     char str4[] = &quot;Dog&quot;;</span></span><br><span class="line"><span class="comment">//     char str5[] = &quot;None&quot;;</span></span><br><span class="line"><span class="comment">//     switch (c)&#123;</span></span><br><span class="line"><span class="comment">//         case &#x27;A&#x27;: return str1;</span></span><br><span class="line"><span class="comment">//         case &#x27;B&#x27;: return str2;</span></span><br><span class="line"><span class="comment">//         case &#x27;C&#x27;: return str3;</span></span><br><span class="line"><span class="comment">//         case &#x27;D&#x27;: return str4;</span></span><br><span class="line"><span class="comment">//         default: return str5;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查询的字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,get_word(c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可能又有人问了，为啥可以直接返回字符串”Apple”…哪些呢？<br>参考ChatGPT回答:<div align="center"><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/指针函数与函数指针_局部变量的指针.jpg" width="90%"></div></li><li>函数指针<br>定义：指向函数的指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> num*num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>); <span class="comment">//定义函数指针，此处第一个int取决于所指向的函数的返回值，第二个int取决于函数的输入参数。就跟函数定义时相同即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数指针</span></span><br><span class="line">fp = square;     <span class="comment">//也可以写成fp = &amp;square; 但没必要，因为一般来说，函数编译后，函数名就是函数的地址。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在主函数中通过函数指针调用函数</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*fp)(num));</span><br><span class="line"><span class="comment">//其实也可以写成 printf(&quot;%d&quot;,fp(num)); 但为了与函数混淆，还是写成上面那种形式比较好。</span></span><br></pre></td></tr></table></figure>需要注意的就是函数编译后，函数名就是函数指针。</li><li>函数指针作为参数<br>举个栗子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数指针作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1 ,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 + 5 = %d\n&quot;</span>,calc(add,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 - 5 = %d\n&quot;</span>,calc(sub,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数指针作为返回值<br>接着上节，举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span>))(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//定义一个参数为char类型，返回值为函数指针的函数.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1 ,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为返回值</span></span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span> op))(<span class="type">int</span> num1, <span class="type">int</span> num2)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> add;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入计算表达式:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;num1,&amp;op,&amp;num2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>,num1,num2,calc(select(op),num1,num2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面，我们可以发现，定义返回值类型为函数指针,参数类型为字符的函数，且所返回的函数指针指向的函数接收两个int类型参数且返回值为int类型的操作为： <code>int (*func(int))(int, int);</code>.<br>函数拓展 &gt;&gt; <code>snprintf函数</code>，函数详解-&gt; <a href="https://fishc.com.cn/thread-68870-1-1.html">传送门</a>.<br>举个栗子😊：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">42</span>;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//将整数42以16进制数的形式写入字符数组</span></span><br><span class="line">    <span class="comment">//42(10) == 2a(16)</span></span><br><span class="line">    <span class="built_in">snprintf</span>(<span class="built_in">array</span>,<span class="number">3</span>,<span class="string">&quot;%02x&quot;</span>,c);</span><br><span class="line">    <span class="comment">//打印字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">array</span>); <span class="comment">//  输出结果为2a，从而印证上述说法.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><ol><li><p>局部变量<br>局部变量（Local Variables）是指在特定范围内声明和使用的变量。这个特定的范围通常是在一个函数或者一个代码块内部。<br>特定范围中一个函数的情况很常见，对于代码块内部，下面举一例进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;before, i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;after, i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环内部的i只作用于该循环，且循环内部调用的i只能是<code>int i = 0</code>这里定义的。在<code>for</code>循环外面调用的i就是<code>int i = 520;</code>这里定义的！！！<br>如下图所示：<br><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/循环内局部变量作用范围.jpg" alt="循环内局部变量"></p><blockquote><p>不过要注意的是，C99才允许上述在<code>for</code>语句中定义变量。因为C99允许在使用时才定义变量，而不是一开始在最上面定义变量。</p></blockquote></li><li><p>全局变量<br>在函数里面定义的，我们叫局部变量；在函数外部定义的，我们叫外部变量，也叫做<strong>全局变量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   a();</span><br><span class="line">   b();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>如果不对全局变量进行初始化，那么它会自动初始化为0</strong>。</li><li>如果在函数的内部存在一个与全局变量同名的局部变量，编译器并不会报错，而是在函数中屏蔽全局变量（也就是说在这个函数中，全局变量不起作用)。</li></ul><p>举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">   a = <span class="number">880</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line">   func();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a + b = <span class="number">520</span></span><br><span class="line">a + b = <span class="number">1000</span></span><br><span class="line">a + b = <span class="number">1400</span></span><br></pre></td></tr></table></figure><p>一般来说编译器不允许先使用变量再定义，否则会报错；<br>但是如果我们使用关键字<code>extern</code>，则是可以的。该关键字的功能就是告诉编译器，我是定义了这个变量的，只不过在后面；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="作用域与链接属性"><a href="#作用域与链接属性" class="headerlink" title="作用域与链接属性"></a>作用域与链接属性</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域包括以下几种类型：</p><ul><li>代码块作用域</li><li>文件作用域</li><li>原型作用域</li><li>函数作用域</li></ul><div class="tabs" id="作用域"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="作用域-1">代码块作用域</button><button type="button" class="tab " data-href="作用域-2">文件作用域</button><button type="button" class="tab " data-href="作用域-3">原型作用域</button><button type="button" class="tab " data-href="作用域-4">函数作用域</button></ul><div class="tab-contents"><div class="tab-item-content active" id="作用域-1"><p>在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志该代码块结束的右大括号(})处。<br>另外，尽管函数的形式参数不在大括号内定义，但其同样具有代码块作用域，隶属于包含函数体的代码块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">120</span>;</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">130</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">130</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="作用域-2"><p>任何在<strong>代码块之外声明的标识符</strong>都具有文件作用域，作用范围是从它们声明位置开始，到文件的结尾处结束。另外，函数名也具有文件作用域，因为函数名本身也在代码块之外。</p><blockquote><p>定义了一定是声明了！！！典型的就是全局变量的定义，故作用范围是从定义的位置开始，到文件结尾处结束！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> count;   <span class="comment">//全局变量声明。当然也可以直接定义，例如在main函数前面写 int count = 0;</span></span><br><span class="line">    func();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main, count = %d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func, count = %d\n&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In func, count = <span class="number">1</span></span><br><span class="line">In main, count = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>很显然，如果没有声明(<code>void func()</code>和<code>extern int count</code>)，那么编译器也不知道后面会有func和count，就报个错先！<br>进一步，可以看出，具有文件作用域的标识符包括<strong>函数名和全局变量</strong>！</p></div><div class="tab-item-content" id="作用域-3"><p>原型作用域(prototype scope)<strong>只适用于那些在函数原型中声明的参数名</strong>。我们知道，函数在声明的时候可以不写参数的名字（但参数类型是必须要写上的），其实尝试一下还可以发现，<strong>函数原型</strong>的参数名还可以随便写一个名字，不必与<strong>函数定义</strong>时的形式参数相匹配（当然，这样做毫无意义)。之所以允许这么做，是因为原型作用域起了作用。<br><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/原型作用域.jpg" alt="原型作用域"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型（亦称为函数声明）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="作用域-4"><p>函数作用域只适用于语句标签（而语句标签用于goto语句）。使用规则：一个函数的所有语句标签必须唯一。<br>goto语句的作用域是一个函数的大小，而不是一个代码块。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h4 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h4><p>啥是链接？可能刚开始比较疑惑，那就看看C语言源代码是如何编程可执行文件(.exe)的吧！—&gt;传送门:[]<br>链接属性分类：</p><ul><li>external（外部属性）：多个文件中声明的同名标识符表示同一个实体。</li><li>internal（内部属性）：单个文件中声明的同名标识符表示同一个实体。</li><li>none（空链接属性）：声明的同名标识符中被当作不同独立的实体。比如，函数的局部变量，因为它们被当作独立不同的实体，所以不同函数间同名的局部变量并不会发生冲突。</li></ul><p>特点：</p><ul><li><strong>只有具备文件作用域的标识符才能拥有external或internal的链接属性</strong>，其他作用域的标识符都是none属性。</li><li>默认情况下，具备文件作用域的标识符拥有external属性。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   a();</span><br><span class="line">   b();</span><br><span class="line">   c();</span><br><span class="line">   b();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>static</strong>关键字对<strong>链接属性</strong>的修改：</p><ol><li>使用static关键字修改链接属性，<strong>只对具有文件作用域的标识符生效</strong>（对于拥有其他作用域的标识符是另一种功能）。(当然只是对链接属性进行了修改，<strong>作用域还是没变</strong>！！！)</li><li><strong>链接属性只能修改一次</strong>，也就是说，一旦将标识符的链接属性变为internal,就无法再变回external了。</li></ol><p>这样做的好处就是保护全局变量，以免在其他文件中被修改！</p><p>本节作用域与链接属性是从空间角度分析的，下面将从时间角度作为切入点！！！</p><h3 id="生存期与存储类型"><a href="#生存期与存储类型" class="headerlink" title="生存期与存储类型"></a>生存期与存储类型</h3><h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>C语言拥有两种生存期：</p><ul><li>静态存储期(static storage duration)</li><li>自动存储期(automatic storage duration)</li></ul><div class="tabs" id="生存期"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="生存期-1">静态存储期</button><button type="button" class="tab " data-href="生存期-2">自动存储期</button></ul><div class="tab-contents"><div class="tab-item-content active" id="生存期-1"><p><strong>具有文件作用域的变量</strong>属于静态存储期，函数也属于静态存储期。属于静态存储期的变量在程序执行期间将一直占据存储空间，<strong>直到程序关闭才释放</strong>。</p></div><div class="tab-item-content" id="生存期-2"><p><strong>具有代码块作用域的变量</strong>一般情况下属于自动存储期。属于自动存储期的变量在<strong>代码块结束时将自动释放存储空间</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><p>C语言提供了五种不同的存储类型：</p><ul><li>atuo(default)</li><li>register</li><li>静态存储变量(static)</li><li>static 和 extern</li><li>typedef</li></ul><div class="tabs" id="存储类型"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="存储类型-1">自动变量(auto)</button><button type="button" class="tab " data-href="存储类型-2">寄存器变量(register)</button><button type="button" class="tab " data-href="存储类型-3">静态局部变量(static)</button><button type="button" class="tab " data-href="存储类型-4">static 和 extern</button><button type="button" class="tab " data-href="存储类型-5">typedef</button></ul><div class="tab-contents"><div class="tab-item-content active" id="存储类型-1"><p><strong>默认适用对象</strong>：函数中的形参、局部变量及复合语句中定义的局部变量等；<br><strong>特性</strong>：拥有代码块作用域、自动存储期和空连接属性(None);<br>在代码块中声明的变量默认的存储类型就是<code>auto</code>，不过auto可以省略，平常我们写的时候就省略了。<br>不过当强调局部变量屏蔽全局变量这一做法时，可以在局部变量前加上auto。</p></div><div class="tab-item-content" id="存储类型-2"><p><strong>声明</strong>：register int i;…<br><strong>特性</strong>：</p><ul><li>代码块作用域、自动存储期和空链接属性；</li><li>不能通过取址运算符(&amp;)获得该变量的地址！！！</li></ul><p>将一个变量声明为寄存器变量，那么该变量就<strong>有可能</strong>被存放于位于CPU的寄存器。为啥说有可能呢？因为CPU的寄存器空间十分有限，所以编译器并不会让所有声明为register的变量都放到寄存器中。<br>事实上，有可能所有的register关键字都被忽略，因为编译器有自己的一套优化方法，会权衡哪些才是最常用的变量。在编译器看来，它比你更了解程序。而那些被忽略的register变量，它们会变成普通的自动变量。</p></div><div class="tab-item-content" id="存储类型-3"><p>首先可能有人会好奇，为啥会叫静态局部变量呢？<br>这就对了，因为static作用于全局变量时，是修改其链接属性。那么static作用于局部变量会发生什么奇妙的事情呢？<br>static作用于局部变量会使<strong>局部变量的生存期</strong>由自动存储期变为静态储存期！由此可得其特性：<br><strong>特性</strong>：空链接属性、代码块作用域、静态存储期。<br>举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      func();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="存储类型-4"><p>此处所指static不同于前述静态局部变量所讲的static。这里所讲static和extern的作用域是文件作用域，static关键字使得默认具有external链接属性的标识符变成internal链接属性，而extern关键字告诉编译器这个变量或函数在别的地方已经定义过了，先去别的地方找找，不要急着报错。</p></div><div class="tab-item-content" id="存储类型-5"><p>该类型将在结构体章节详细阐述！！！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>切记：递归一定要有结束条件！<br>基操：实现阶乘<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recursion(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d! = %d&quot;</span>,n,recursion(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>小试牛刀：</p><div class="tabs" id><ul class="nav-tabs"><button type="button" class="tab  active" data-href="-1">汉诺塔</button><button type="button" class="tab " data-href="-2">快速排序</button></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/递归-汉诺塔.jpg" alt="汉诺塔"><br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>, <span class="type">char</span>, <span class="type">char</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span>&#123;   <span class="comment">//表示的意义为：从x移到z位置，借助y；</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        func(n<span class="number">-1</span>, x, z, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, x, z);</span><br><span class="line">        func(n<span class="number">-1</span>, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>,y = <span class="string">&#x27;y&#x27;</span>,z = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input story:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    func(n,x,y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="-2"><p><img src="/2024/OldBlogs/%E7%A0%B4%E5%B1%80/递归-快速排序.jpg" alt="快速排序"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *p,  <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = end;</span><br><span class="line">    <span class="type">int</span> judge = p[(start+end)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (; p[i] &lt; judge; i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; p[j] &gt; judge; j--)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = p[i];</span><br><span class="line">        p[i] = p[j];</span><br><span class="line">        p[j] = temp;</span><br><span class="line">        i++;    <span class="comment">//特别要注意，比较完之后要向中间靠拢，否则遇见p[i] == p[j]的情况就会陷入死循环！</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后i和j一定是相邻的！因为i走过的必定是满足p[i] &lt; judge，也就不可能满足p[j] &gt; judge了；同理，j走过的必定不可能满足i，故i,j最后会相邻，且i &gt; j!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; start)&#123;</span><br><span class="line">        quick_sort(p, start, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; end)&#123;</span><br><span class="line">        quick_sort(p, i, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">388</span>,<span class="number">458</span>,<span class="number">253</span>,<span class="number">245</span>,<span class="number">356</span>,<span class="number">356</span>,<span class="number">122</span>,<span class="number">223</span>,<span class="number">245</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, length;</span><br><span class="line"></span><br><span class="line">    length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    quick_sort(<span class="built_in">array</span>, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the sorted result is\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= length; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><p>在之前所学中，变量一经定义，其内存大小就不能再更改了！那么有什么办法能让C语言更灵活地管理内存资源呢？<br>答案是有的，需要借助几个库函数，这几个库函数在<code>stdlib.h</code>这个头文件中！</p><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><br>malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的指针。不过要注意，申请的这块空间并没有被“清理”（初始化为0），所以它上面的数据是随机的（就与局部变量一样）。</p><ul><li>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针(void*),所以它可以被转换成任何类型的数据：</li><li>如果函数调用失败，返回值是NULL。</li><li>另外，如果size参数设置为O,返回值也可能是NULL,但这并不意味着函数调用失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num is %d\n&quot;</span>,*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><br>由于malloc函数申请的空间位于内存的堆上，如果不主动释放它，那么它会一直存在直到程序结束！<br>所以以后写程序，<code>malloc</code>和<code>free</code>要成对！<br>故上面程序应该为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num is %d\n&quot;</span>,*ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);    <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>内存泄漏指的是在程序运行过程中，动态分配的内存空间没有被正确释放的情况。导致内存泄漏主要有以下两种情况：</p><ol><li>隐式内存泄漏(即用完内存块没有及时使用free函数释放掉)；</li><li>丢失内存地址；</li></ol><p>丢失内存地址就是说把原本指向动态申请的内存地址的指针指向别的地方了。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">ptr = &amp;num; <span class="comment">//丢失内存地址</span></span><br></pre></td></tr></table></figure></p><h4 id="申请任意尺寸的内存空间"><a href="#申请任意尺寸的内存空间" class="headerlink" title="申请任意尺寸的内存空间"></a>申请任意尺寸的内存空间</h4><p>malloc不仅可以申请基本类型数据的空间，还可以申请一块任意的内存空间。对于后者，由于申请得到的空间是连续的，通常采用数组来进行索引。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于malloc并不会初始化申请的内存空间，所以需要自己进行初始化。当然可以写个循环来做这件事，但不建议这么做，标准库提供了更加高效的函数：<code>memset</code>。以mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中.—&gt;<a href="https://fishc.com.cn/thread-80241-1-1.html">memset函数传送门</a>.</p><blockquote><p>除了memset函数之外，类似的还有memcpy，memmove，memcmp等等，可见小甲鱼函数快查.—&gt;<a href="https://fishc.com.cn/thread-66397-1-1.html">传送门</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>,i,ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的同学可能发现了，这样每次写完<code>malloc</code>，还要再写<code>memset</code>，略显繁琐，于是C语言提供了<code>calloc</code>函数一步实现上述功能！</p><h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></p><p>calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间(即申请的总空间尺寸为nmemb*size)，这些内存空间全部被初始化为0。</p><p>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针(void*)，所以它可以被转换成任何类型的数据：如果函数调用失败，返回值是NULL。如果nmemb或size参数设置为O，返回值也可能是NULL，但这并不意味着函数调用失败。</p><p>calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为0，而malloc函数不进行初始化操作，里边数据是随机的。因此，下面两种写法是等价的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">8</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(ptr, <span class="number">0</span>, <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p><h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><p>在现实操作中，我们会经常碰到内存空间不足的问题，需要扩展，此时可以借<code>malloc</code>和<code>memccpy</code>进行扩充：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr1;</span><br><span class="line">    <span class="type">int</span> *ptr2;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ptr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>((num*<span class="number">2</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr2, ptr1, num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    ptr2[num] = <span class="number">5201314</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr2[%d] == %d\n&quot;</span>, num, ptr2[num]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr2[%d] == %d\n&quot;</span>,i, ptr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的操作比较繁琐，还好C语言有相应的库函数，没错，就是<code>realloc</code>!<br>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></p><p>不过需要注意以下几点：</p><ul><li>realloc函数将ptr指向的内存空间大小修改为size字节。</li><li>如果新分配的内存空间比原来的大，则旧内存块的数据不会发生改变：如果新分配的内存空间比原来的小，则可能导致数据丢失，请慎用。</li><li>该函数将移动内存空间的数据并返回新的指针。</li><li>如果ptr参数为NULL，那么调用该函数就相当于调用malloc(size)。</li><li>如果size参数为0，并且ptr参数不为NULL,那么调用该函数就相当于调用free(ptr)。</li><li>除非ptr参数为NULL,否则，ptr的值必须由先前调用malloc、calloc或realloc函数返回。</li></ul><p>编写一个程序，不断地接收用户输入的整数，直到用户输入-1表示输入结束，将所有数据打印出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;    <span class="comment">//此处必须初始化为NULL，因为realloc()参数中要求了！如前述注意事项最后一点！</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input number(-1: exit):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        count++;</span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr,count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        ptr[count<span class="number">-1</span>] = num;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>无论是malloc、calloc还是realloc函数，都需要搭配free函数释放内存！</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="顺序读写文件"><a href="#顺序读写文件" class="headerlink" title="顺序读写文件"></a>顺序读写文件</h3><p>本节主要练习那些文件操作函数，见传送门-&gt;<a href="https://fishc.com.cn/thread-66397-1-1.html">C语言函数索引</a><br>常用的，例如：</p><ul><li>fopen();</li><li>fputc()/putc();  (区别于putchar，看着很像)</li><li>fgetc()/getc(); （区别于getchar()）</li><li>fputs();</li><li>fgets();</li></ul><p>这一节还有几个比较有趣的拓展阅读:</p><ul><li><a href="https://fishc.com.cn/thread-91062-1-2.html">如何理解万物皆文件</a></li><li><a href="https://fishc.com.cn/thread-92251-1-2.html">文本流与二进制流的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构设计杂谈</title>
      <link href="/2024/OldBlogs/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/"/>
      <url>/2024/OldBlogs/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><strong>后续不再更新，主要是本科学习对于结构设计的心得。</strong></p><h1 id="内力组合相关疑惑"><a href="#内力组合相关疑惑" class="headerlink" title="内力组合相关疑惑"></a>内力组合相关疑惑</h1><p>以框架结构为例，<strong>抗震设计</strong>时，内力组合遵循一下原则：（电脑也是这么算的，具体可以参见<strong>广厦计算结果</strong>）<br>注意：下面 $\gamma _ { GE }$ 取1.2是老规范，新规范是1.3.<br><div class="row">    <embed src="内力组合分析.pdf" width="100%" height="550" type="application/pdf"></div></p><p>关键要义：<strong>在同一个组合下一直算（包括强柱弱梁等内力调整，要在同一个组合内调整），然后最后截面设计时再在不同组合中取最不利的值</strong>。<br>广厦内力组合如下，验证了上面的想法。</p><div align=center><img src="广厦内力组合.jpg" width="90%"></div><h1 id="振型分解反应谱法-弹性分析"><a href="#振型分解反应谱法-弹性分析" class="headerlink" title="振型分解反应谱法(弹性分析)"></a>振型分解反应谱法(弹性分析)</h1><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p><a href="https://coe.ouc.edu.cn/2022/0527/c9093a371372/page.htm">谭启阳老师</a>给我们上钢结构设计课程时讲到了振型分解反应谱法，之前学的不够深入，很多都是半知半解。结合我的一些笔记和理解，现分享如下：<br><div class="row">    <embed src="振型分解反应谱法.pdf" width="100%" height="550" type="application/pdf"></div></p><p>看完上面也就理解了振型参与质量系数$\mu _ { i }$和振型有效质量系数$\sum _ { i = 1 } ^ { j } \mu _ { i }$,其中j表示累加到第j振型。<br>一般第一阶振型的振型参与质量系数在0.85左右，这也是为啥底部剪力法中等效质量取总质量的0.85倍了(如下式)。</p><script type="math/tex; mode=display">G _ { e q } = 0.85 \sum _ { i = 1 } ^ { n } G _ { i }</script><h2 id="具体细节证明"><a href="#具体细节证明" class="headerlink" title="具体细节证明"></a>具体细节证明</h2><h3 id="特征值方程解的问题"><a href="#特征值方程解的问题" class="headerlink" title="特征值方程解的问题"></a>特征值方程解的问题</h3><p>上述推导过程中提到：通过解频率方程 $| K - \omega ^ { 2 } M | = 0$ ，能得到的n个正特征值(可能有重根)和n个线性无关的特征向量。其中为啥一定能得到n个线性无关的特征向量？<br>答：n个互不相同频率对应的特征向量很容易证明线性无关，线性代数书上也有相关证明。那如果n个频率中有重频的话，重频对应的特征向量也线性无关吗？答案是可以找到线性无关的特征向量，也可以找到线性相关的。具体可参考<a href="https://www.zhihu.com/question/625663327/answer/3255480547?utm_id=0"><strong>为什么实对称矩阵相同的特征值对应的特征向量可以线性无关，也可以线性相关？</strong></a></p><h3 id="结构刚度矩阵正定问题"><a href="#结构刚度矩阵正定问题" class="headerlink" title="结构刚度矩阵正定问题"></a>结构刚度矩阵正定问题</h3><p>如何证明<strong>结构的刚度矩阵</strong>的刚度一定是正定的？<br>答：从物理意义方面，可以利用应变能来证明；从数学方面，可以通过结构平衡-几何矩阵互伴定理来证明，具体证明见本博客文章：<strong>力学基础与专业基础</strong>—结构力学—结构平衡-几何互伴定理这一板块。</p><h1 id="底部剪力法-弹性分析"><a href="#底部剪力法-弹性分析" class="headerlink" title="底部剪力法(弹性分析)"></a>底部剪力法(弹性分析)</h1><div class="row">    <embed src="底部剪力法.pdf" width="100%" height="550" type="application/pdf"></div><p>注意底部剪力法的适用范围！</p><h1 id="时程分析法-弹性分析、弹塑性分析"><a href="#时程分析法-弹性分析、弹塑性分析" class="headerlink" title="时程分析法(弹性分析、弹塑性分析)"></a>时程分析法(弹性分析、弹塑性分析)</h1><h2 id="中心差分法"><a href="#中心差分法" class="headerlink" title="中心差分法"></a>中心差分法</h2><div class="row">    <embed src="时程分析-中心差分法.pdf" width="100%" height="550" type="application/pdf"></div><p>从上述资料中可以看出，以线弹性体系为例，有：</p><script type="math/tex; mode=display">\scriptstyle X _ { i + 1 } = ( \frac { M } { \Delta t ^ { 2 } } + \frac { C } { 2 \Delta t } ) ^ { - 1 } \left[ - M \{1\}\ddot { X } _ { g , i } - ( \frac { M } { \Delta t ^ { 2 } } - \frac { C } { 2 \Delta t } ) X _ { i - 1 } - ( K - \frac { 2 M } { \Delta t ^ { 2 } } ) X _ { i } \right]</script><p>当我们给定地震加速度时程曲线(也就已知上式中 $\ddot { X } _ { g , i }$ )，(第0时刻和第-1时刻由上述资料可知是已知的)，就可以求出任意时刻结构体系的位移，也即得到了结构体系的位移时程曲线。</p><h1 id="焊接纵向、横向残余应力的理解"><a href="#焊接纵向、横向残余应力的理解" class="headerlink" title="焊接纵向、横向残余应力的理解"></a>焊接纵向、横向残余应力的理解</h1><ol><li><p>焊接纵向残余应力<br>所谓<strong>纵向</strong>，就是<strong>应力方向与焊缝长度方向平行</strong>。如下图所示。</p><div align=center><img src="焊接纵向残余应力.jpg" width="70%"></div><div align=center><img src="焊接纵向残余应力-1.jpg" width="70%"></div><p>对于是<strong>拉应力还是压应力</strong>，应该这么理解：在冷却时，高温的部分受到已经冷却（或者说热影响不大）的区域限制，限制它<strong>收缩</strong>，故在其中产生了拉应力。由于板件<strong>未受外力</strong>，截面必然<strong>平衡</strong>，故两端的纵向残余应力为<strong>压应力</strong>。</p></li><li>焊接横向残余应力<br>所谓<strong>横向</strong>就是<strong>应力方向垂直于焊缝长度方向</strong>，例如两块板对接焊，当焊缝<strong>纵向收缩</strong>时，两块板件有向相反反向弯曲的趋势，造成焊缝中部<strong>两端受压，中间受拉</strong>。如下图所示。<div align=center><img src="焊接横向残余应力.jpg" width="70%"></div></li></ol><h1 id="剪力墙按受力特性的分类及其受力特征"><a href="#剪力墙按受力特性的分类及其受力特征" class="headerlink" title="剪力墙按受力特性的分类及其受力特征"></a>剪力墙按受力特性的分类及其受力特征</h1><ol><li><strong>整体墙</strong><br>定义：无洞口的剪力墙或剪力墙上开有一定数量的洞口，但洞口的面积不超过墙体面积的16%，且洞口至墙边的净距及洞口之间的净距大于洞孔长边尺寸时，可以忽略洞口对墙体的影响，这种墙体称为整体剪力墙。<br>受力特征：整体剪力墙的受力状态如同竖向悬臂梁，截面变形后仍符合平面假定，<strong>因而截面应力可按材料力学公式计算</strong>，变形属弯曲型。</li><li><strong>整体小开口墙</strong><br>定义：当剪力墙上所开洞口面积稍大且超过墙体面积的16%时，在水平荷载作用下，这类剪力墙截面上的正应力分布略偏离了直线分布的规律，变成了相当于在整体墙弯曲时的直线分布应力之上叠加了墙肢局部弯曲应力，当墙肢中的局部弯矩不超过墙体整体弯矩的15%时，其截面变形仍接近于整体截面剪力墙，这种剪力墙称之为小开口整体剪力墙。<br>受力特征：<strong>对于小开口剪力墙，其截面变形大体上仍符合平面假定，正应力大体上呈直线分布。为计算方便，力和变形仍按材料力学计算，然后适当修正。</strong>（一般<strong>内力计算</strong>是：将总力矩的85%按材料力学的方法计算墙肢弯矩及轴力，将总力矩的15%按墙肢的刚度进行分配。<strong>位移的计算</strong>：按照整体墙计算，不过考虑到洞口削弱墙体刚度，最终结果要放大20%）</li><li><p><strong>联肢墙</strong><br>定义：当剪力墙沿竖向开有一列或多列较大的洞口时，由于洞口较大，剪力墙截面的整体性已被破坏，剪力墙的截面变形已不再符合平截面假设。这时剪力墙成为由一系列连梁约束的墙肢所组成的联肢墙。<br>受力特征：洞口开得比较大，截面的整体性已经破坏，<strong>横截面上正应力的分布远不是遵循沿一根直线的规律。</strong>但墙肢的线刚度比同列两孔间所形成的连梁的线刚度大得多，每根连梁中部有反弯点，各墙肢单独弯曲作用较为显著，但仅在个别或少数层墙肢出现反弯点。<strong>其变形曲线与整体小开口墙相近，仍以弯曲变形为主</strong>，内力计算宜采用连续化方法，例如<strong>连续连杆法</strong>。<br><code>连续连杆法基本假定</code>:</p><ol><li>连梁反弯点位于跨中，连梁的作用可以用沿高度 均匀分布的连续弹性薄片代替。</li><li>各墙肢的刚度相差不过分悬殊，因而变形曲线相似。</li><li>连梁和墙肢考虑弯曲和剪切变形，墙肢还应考虑轴向变形的影响。</li><li>各墙肢、连梁截面尺寸、材料强度及层高沿剪力墙全高相同。</li></ol><p><strong>基本原理</strong>：运用力法原理，将连梁中点切开，去掉多余约束，建立静定体系。切开后连杆剪力是多余未知力，是一个连续函数。由切开处的变形协调条件建立连杆剪力的微分方程，求解微分方程即得连杆剪力 。将层高范围内的各点剪力积分还原成一根连梁的剪力。各层连梁中点剪力求出后，所有墙肢及连梁内力都可相继求出。</p></li><li><strong>壁式框架</strong><br>定义：当剪力墙的洞口尺寸较大，墙肢宽度较小，连梁的线刚度接近于墙肢的线刚度时，剪力墙的受力性能已接近于框架，这种剪力墙称为壁式框架。<br>受力特征：洞口开得比联肢剪力墙更宽，墙肢宽度较小，墙肢与连梁刚度接近时，墙肢明显出现局部弯矩，在许多楼层有反弯点。剪力墙的内力分布接近框架。壁式框架实质是介于剪力墙和框架之间的一种过渡形式，它的变形已很接近剪切型。只不过壁柱和壁梁都较宽，因而在梁柱交接区形成不产生变形的刚域。</li></ol><h1 id="框架剪力墙结构内力计算"><a href="#框架剪力墙结构内力计算" class="headerlink" title="框架剪力墙结构内力计算"></a>框架剪力墙结构内力计算</h1><p>🖋️核心思路：将所有框架合并为总框架，所有剪力墙合并为总剪力墙，外力在框架和剪力墙之间的分配由协同工作计算确定，协同工作计算采用连续连杆法。<br>PS: 后面《钢结构设计》中框架支撑体系的计算也是如此思路，只是把剪力墙换为支撑。</p><div class="row">    <embed src="框架剪力墙结构内力计算.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="双向板计算"><a href="#双向板计算" class="headerlink" title="双向板计算"></a>双向板计算</h1><p>对于双向板的设计，有<strong>弹性设计</strong>和<strong>塑性设计</strong>两种。对于弹性设计，是通过查表得出弯矩设计值，书上也容易理解。对于塑性设计，书上采用了<strong>塑性铰线法</strong>，通过一系列推到，得到荷载P作用时，板的弯矩（书上表述为<strong>承载力</strong>，尚有不妥，应该为<strong>内力</strong>更好），然后配筋设计了。</p><div align=center><img src="双向板塑性设计.jpg" width="80%"></div><div align=center><img src="双向板塑性设计计算公式.jpg" width="80%"></div><p>从中也可以发现，所谓弹性设计、塑性设计，归纳起来就是<strong>以何种状态的抗力去抵抗该状态下的效应就是何种设计。</strong></p><p><strong>何为单向板与双向板？</strong><br>在学习《混凝土结构基本原理》之初，对于单向板，我们是按照长边/短边大于2（具体分为大于等于3和介于2-3之间）的原则来判断的。久而久之容易形成刻板印象，只通过边长比值来判断，这是不可取的。（见《混凝土》下册P30）<br>而实际上单向板和双向板定义：只在一个方向弯曲或主要在一个方向弯曲的板称为单向板；在两个方向弯曲且不能忽略任一方向弯曲的板称为双向板。</p><h1 id="应力应变、内力与位移之间关系"><a href="#应力应变、内力与位移之间关系" class="headerlink" title="应力应变、内力与位移之间关系"></a>应力应变、内力与位移之间关系</h1><p><strong>应力与应变之间关系</strong>：<br>有应力不一定有应变（这个命题本身不是很严谨）比如三个方向应力取值得当可以使得某一方向无应变。<br>有应变不一定有应力，比如静定结构由于温度差异产生的应变。<br><strong>内力和位移之间联系</strong>：<br>有内力不一定有位移。比如超静定结构中，由于温度变形受到限制而产生内力，但无位移。<br>有位移不一定有内力。比如静定结构支座位移并不产生内力。<br>关于<strong>位移和变形</strong>的区别，可以参考如下：</p><div align=center><img src="位移、变形的区别.png" width="70%"></div><h1 id="结构设计理论发展"><a href="#结构设计理论发展" class="headerlink" title="结构设计理论发展"></a>结构设计理论发展</h1><p>认识、梳理工程结构设计理论的发展历史与发展状况 ，需要从两个基本维度加以考察：</p><ul><li>对结构受力力学行为的科学反映方式；</li><li>对工程中客观存在的不确定性的科学度量方式；</li></ul><h2 id="第一代结构设计理论"><a href="#第一代结构设计理论" class="headerlink" title="第一代结构设计理论"></a>第一代结构设计理论</h2><script type="math/tex; mode=display">\sigma  \le \left[ \sigma  \right]</script><p>式中$[ \sigma ]$为允许应力或容许应力强度，按下式计算：</p><script type="math/tex; mode=display">\left[ \sigma  \right] = \frac{R}{K}</script><p>式中，R为材料强度，K为结构安全系数。</p><h2 id="第二代结构设计理论"><a href="#第二代结构设计理论" class="headerlink" title="第二代结构设计理论"></a>第二代结构设计理论</h2><p>由于Cornell、Ang、Lind等人的杰出工作，基于低阶统计矩的一次二阶矩理论开始完善，并被十分精彩地表达为分项系数设计公式（以结构恒载与活载组合为例)：</p><script type="math/tex; mode=display">{\gamma _R}R \ge {\gamma _G}G + {\gamma _Q}Q</script><p>我国规范中表述的一般形式如下：</p><script type="math/tex; mode=display">\frac{R}{ { {\gamma _R}}} \ge {\gamma _S}S</script><p>由于低阶矩仅能反映荷载与结构抗力分布的主要特征，作为设计衡量标准的可靠度指标β与失效概率之间的关系又基于正态分布假定，因此，人们将这一设计理论称为考虑多种极限状态的<strong>近似概率设计法</strong>（亦称近似概率极限状态设计方法），它构成了第二代结构设计理论的核心。</p><h2 id="第三代结构设计理论"><a href="#第三代结构设计理论" class="headerlink" title="第三代结构设计理论"></a>第三代结构设计理论</h2><p>第二代结构设计理论存在两个基本矛盾：</p><ul><li>在构件设计层次考虑非线性、而在结构分析层次忽略非线性；</li><li>在构件设计层次考虑随机性、而在结构分析层次不承认随机性影响。</li></ul><p>第三代结构设计理论致力于解决上述问题，其基本框架为：<br><img src="第三代结构设计理论框架.jpg" alt="第三代结构设计理论框架"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 李杰. 论第三代结构设计理论[J]. 同济大学学报(自然科学版), 2017, 45(5): 617-624+632.</p>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构设计杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力学基础和专业基础</title>
      <link href="/2024/OldBlogs/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/OldBlogs/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要是大三准备保研时复习专业课写的，后续不再更新此篇，有更新的发现会单独成篇，更易阅读。</strong></p><h2 id="材料力学"><a href="#材料力学" class="headerlink" title="材料力学"></a>材料力学</h2><ol><li>最近学了拉压、扭的部分，大致思路都是<strong>强度-刚度-应变能</strong>，公式也很类似。下面分享几个比较有意思的点：<br>第一个是<strong>小变形放大图</strong>，常用来解决超静定问题，依靠<strong>平衡方程</strong>和<strong>变形协调方程</strong>，再加上本构方程。这里的<strong>变形协调</strong>其实就是后面<strong>力法方程的本质</strong>，可以说是埋下伏笔了。</li><li>第二个是<strong>功互等定理</strong>和<strong>位移互等定理</strong>，在材料力学中只是当作附加部分讲了讲，并没有涉及其本质，具体推导可以参见 <strong>《结构力学》（龙驭球）第五章最后一节</strong>，用虚功原理予以解释，此外，那里还介绍了两个互等定理。注意：上述四个互等定理只适用于<strong>线性变形体系</strong>。 </li><li><strong>剪应力互等定理</strong>新的理解<br> 详细可以参考一下这篇文章。感觉与以前理解不同的地方在于：取出来的单元体实际上六个面均有力，每个面有两个方向的切应力和一个正应力，相对的面上应力相等。（他给出的解释是单元体足够小，可以看作一个点，故相对的两个面力相等） <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.zhihu.com<span class="regexp">/question/</span><span class="number">21070058</span></span><br></pre></td></tr></table></figure></li><li>非对称纯弯曲梁的正应力（《材料力学》下册1-1节）<br>推导得到了<strong>广义弯曲正应力</strong>，有一个印象即可。对于<strong>非对称弯曲</strong>，应该是指梁不具有对称平面，或者梁具有对称平面，但外力不作用在该平面内，梁将发生非对称弯曲。</li><li><p>开口薄壁截面梁的剪应力流和弯曲中心<br><strong>截面剪应力流的方向确定</strong>：(简单的根据：与剪力平行的截面上剪应力流与剪力平行，例如矩形截面，工字形截面的腹板等。)</p><ol><li>根据截面弯矩和中性轴确定拉压应力；(方便下一步由正应力合成轴力)</li><li>切开构件，取隔离体，根据隔离体轴力平衡，非自由面取切应力(一般只有3个非自由面，其中有两个是前后轴力方向，另一个面取剪应力来平衡)，然后再根据剪应力互等定理确定前后两个非自由面上剪应力方向。</li></ol><div class="row">    <embed src="弯曲中心.pdf" width="100%" height="550" type="application/pdf"></div><p>而弯曲中心的确定方法见《材料力学合并文档》P252.核心就是<strong>截面上剪应力合成到某点，只有力而无力偶，该点即为弯曲中心</strong>。<br>重点是<strong>弯曲中心（剪切中心）的作用</strong>：非对称截面梁发生平面弯曲的条件：<strong>外力必须作用在通过弯曲中心且平行于形心主惯性平面（或与之重合）的平面内。</strong></p></li><li><p>梁挠曲微分方程的推导，记得之前啊弄懂了的，不知道最近为啥又迷糊了，还是记录下来吧。<br><img src="//husj0711.top/2024/OldBlogs/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/image-20241221021035633.png" alt="image-20241221021035633" style="zoom:67%;"><br>这里给出个大致提示，具体参考《材料力学》（孙训芳）P121.</p></li></ol><h2 id="结构力学"><a href="#结构力学" class="headerlink" title="结构力学"></a>结构力学</h2><h3 id="单自由度结构自由振动自振频率的求解"><a href="#单自由度结构自由振动自振频率的求解" class="headerlink" title="单自由度结构自由振动自振频率的求解"></a>单自由度结构自由振动自振频率的求解</h3><blockquote><p>2024.11.17记，如今学了结构动力学，看到这道题目，难免不禁感慨，当时弄得太复杂啦，实际上单自由度结构体系求自振频率相当简单。</p></blockquote><p>今天复习了结构动力学基础中一个重要问题——单自由度结构体系自由振动自振频率的求解。困扰了将近一年的问题今天终于搞定了。顺便复习了<strong>科氏加速度</strong>等几个概念，具体参见《理论力学》P190.<br><div class="row">    <embed src="单自由度结构体系自振频率求解.pdf" width="100%" height="550" type="application/pdf"></div></p><h3 id="虚功原理、虚力原理与虚位移原理辨析"><a href="#虚功原理、虚力原理与虚位移原理辨析" class="headerlink" title="虚功原理、虚力原理与虚位移原理辨析"></a>虚功原理、虚力原理与虚位移原理辨析</h3><div class="row">    <embed src="虚功原理、虚力原理与虚位移原理.pdf" width="100%" height="550" type="application/pdf"></div><p>根据上述资料，可知虚功原理表述为：<br>如果<strong>力系满足平衡方程，变形状态满足协调方程</strong>，则虚功方程（下式）成立。</p><script type="math/tex; mode=display">\begin{equation*} \sum F _ { P } \Delta + \sum F _ { R K } C _ { K } = \sum \int _ { A } ^ { B } ( Mk+ F _ { N } \varepsilon + F _ { Q } \gamma _ { 0 } ) d s\end{equation*}</script><p><strong>然后，单独一个虚功方程只是必要条件，而不是充分条件。</strong><br>由此引出一个想法：能否将虚功原理及其虚功方程(上式)加以改造，使改造后的“虚功型方程”（指：用虚功形式表示的方程）成为变形协调方程或力系平衡方程的充分必要条件呢？于是，就产生了下列两个“虚功型原理”一虚力原理和虚位移原理。</p><p><strong>虚力原理</strong>：<br><strong>在虚设力系满足平衡方程且具有任意性的前提下</strong>，如果虚力方程（下图）成立，则待检查的变形状态必满足变形协调方程。反之，在上述前提下，如果已知该变形状态满足变形协调方程，则虚力方程必成立。综合起来，在上述前提下，虚力方程是变形协调方程的充分必要条件。</p><div align="center"><img src="//husj0711.top/2024/OldBlogs/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚力方程.jpg" width="70%"></div><p><strong>虚位移原理</strong>：<br><strong>在虚设变形状态满足变形协调方程并具有任意性的前提下</strong>，如果虚位移方程(下式)成立，则待检查的力系必满足平衡方程。反之，在上述前提下，如果已知该力系满足平衡方程，则虚位移方程必成立。综合起来，在上述前提下，虚位移方程是力系平衡方程的充分必要条件。</p><div align="center"><img src="//husj0711.top/2024/OldBlogs/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚位移方程.jpg" width="70%"></div><h3 id="结构对称性探究"><a href="#结构对称性探究" class="headerlink" title="结构对称性探究"></a>结构对称性探究</h3><div class="row">    <embed src="结构对称性探究.pdf" width="100%" height="550" type="application/pdf"></div><p>正是由于上述结论，可将奇/偶跨对称结构简化，<strong>简化的要求是与原结构等效，表现为力和变形条件。</strong><br>值得注意的是，<strong>对称轴处的荷载要减半，当然最终结果加和时，对称轴处相当于加了两次，合理的。</strong> 可参考下面这两篇文章：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章一：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">576399081</span></span><br><span class="line">文章二：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">147244195</span></span><br></pre></td></tr></table></figure></p><h4 id="对称边界与反对称边界位移条件"><a href="#对称边界与反对称边界位移条件" class="headerlink" title="对称边界与反对称边界位移条件"></a>对称边界与反对称边界位移条件</h4><p>最近学习了<strong>水哥ansys初级教程</strong>，其中谈到<strong>对称边界和反对称边界位移条件时</strong>时，有：</p><ol><li>受对称载荷作用则对称面上的位移条件为<ol><li>垂直于对称面的移动位移分量为零。</li><li>绕平行于对称面的两相互垂直的轴的转动位移分量均为零。</li></ol></li><li>受反对称载荷作用则对称面上的位移条件为<ol><li>平行于对称面的移动位移分量为零；</li><li>绕方向矢量垂直于对称面的轴的转动位移分量为零。</li></ol></li></ol><h3 id="结构平衡-几何矩阵互伴定理"><a href="#结构平衡-几何矩阵互伴定理" class="headerlink" title="结构平衡-几何矩阵互伴定理"></a>结构平衡-几何矩阵互伴定理</h3><p>定理证明：</p><ul><li>龙驭球《结构力学》下册 第14章</li></ul><p>定理的运用，以老师留的习题为例：<br><div class="row">    <embed src="结构平衡-几何矩阵互伴定理.pdf" width="100%" height="550" type="application/pdf"></div></p><hr><p>上述资料是按照矩阵分析一步步来的，略显繁琐，谭启阳老师讲了另一种方法，如下面这个所示，关键就是<strong>力系平衡和变形协调</strong>！<br><div class="row">    <embed src="结构平衡-几何矩阵互伴定理(老师解答).pdf" width="100%" height="550" type="application/pdf"></div></p><p>其实，通过结构平衡-几何矩阵互伴定理可以推出结构刚度矩阵正定的，这里我以上述题目为例，验证如下：<br>已知：</p><script type="math/tex; mode=display">Af = F</script><script type="math/tex; mode=display">BX = \Delta</script><p>且</p><script type="math/tex; mode=display">A = {B^T}</script><p>证明：<br>现设矩阵C如下：<br>$$C = \left[ {\begin{array}{*{20}{c}}{\frac{{EA}}{{{l_1}}}}&0&0\\0&{\frac{{EA}}{{{l_2}}}}&0\\0&0&{\frac{{EA}}{{{l_3}}}}\end{array}} \right]$$</p><p>将方程$BX = \Delta$左右两端同左乘C，则有：</p><script type="math/tex; mode=display">CBX = C\Delta</script><p>又根据$C\Delta  = f$，则有：</p><script type="math/tex; mode=display">BCX = f</script><p>方程两边再同左乘$A$，则有：</p><script type="math/tex; mode=display">ACBX = Af = F</script><p>由于$A = {B^T}$，推出：</p><script type="math/tex; mode=display">{B^T}CBX = F</script><p>显然，刚度矩阵$K = {B^T}CB$，现令$C = {D^T}D$，$Q = DB$，则刚度矩阵转化为：</p><script type="math/tex; mode=display">K = {Q^T}Q</script><p>由于$Q$是可逆矩阵，根据线性代数知识知，$K$必为正定矩阵。<br>得证！ </p><h3 id="结构刚度矩阵推导的两种方法"><a href="#结构刚度矩阵推导的两种方法" class="headerlink" title="结构刚度矩阵推导的两种方法"></a>结构刚度矩阵推导的两种方法</h3><div class="row">    <embed src="结构刚度矩阵推导的两种方法.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="分层法迭代过程"><a href="#分层法迭代过程" class="headerlink" title="分层法迭代过程"></a>分层法迭代过程</h3><div class="row">    <embed src="分层法迭代过程.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="土力学"><a href="#土力学" class="headerlink" title="土力学"></a>土力学</h2><p>由于较少从事这方面研究，目前待更新！！！</p><h2 id="混凝土结构基本原理"><a href="#混凝土结构基本原理" class="headerlink" title="混凝土结构基本原理"></a>混凝土结构基本原理</h2><h3 id="钢筋混凝土受扭构件承载力公式推导的两种方法"><a href="#钢筋混凝土受扭构件承载力公式推导的两种方法" class="headerlink" title="钢筋混凝土受扭构件承载力公式推导的两种方法"></a>钢筋混凝土受扭构件承载力公式推导的两种方法</h3><p>此文章写于大三下学期，目前来看，这两种方法的本质相同，第一种根据q相同求得，第二种根据Tu相同求得，但又有 </p><script type="math/tex; mode=display">\begin{equation*} T_{u} = 2qA_{cor}\end{equation*}</script><p>故其本质相同。<br><div class="row">    <embed src="钢筋混凝土受扭构件承载力.pdf" width="100%" height="550" type="application/pdf"></div></p><h2 id="钢结构基本原理"><a href="#钢结构基本原理" class="headerlink" title="钢结构基本原理"></a>钢结构基本原理</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><h4 id="轴心受压、受弯及压弯构件的宽厚比限值"><a href="#轴心受压、受弯及压弯构件的宽厚比限值" class="headerlink" title="轴心受压、受弯及压弯构件的宽厚比限值"></a>轴心受压、受弯及压弯构件的宽厚比限值</h4><p>宽厚比限值的根本目的是为了防止局部失稳先于整体失稳。由此，规范采用等稳定性原则，即板件屈曲应力不小于构件屈曲应力。</p><script type="math/tex; mode=display">\begin{equation*} \sigma_{crx}\geq \sigma _{cr}\end{equation*}</script><p>同时，根据<strong>以何种状态下（例如弹性）抗力抵抗该种状态下效应即为该种状态设计</strong>，故当板件弹性屈曲应力不小于构件弹性屈曲应力，为<strong>弹性设计</strong>。</p><script type="math/tex; mode=display">\begin{equation*} \frac{b_{1}}{t}\leq 15 \varepsilon _{k}\end{equation*}</script><p>这些天(2023-10-17)恰好在学习冷弯薄壁型钢的设计，这里举例如下：</p><div align="center"><img src="//husj0711.top/2024/OldBlogs/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/冷弯薄壁型钢整体屈曲与局部屈曲关系.jpg" width="70%"></div><h2 id="土木工程施工"><a href="#土木工程施工" class="headerlink" title="土木工程施工"></a>土木工程施工</h2><h3 id="土方工程"><a href="#土方工程" class="headerlink" title="土方工程"></a>土方工程</h3><h4 id="基坑支护"><a href="#基坑支护" class="headerlink" title="基坑支护"></a>基坑支护</h4><p>基坑支护包括一般基坑支护和深基坑支护。<br>深基坑支护方法有：</p><ol><li><strong>水泥土挡墙式支护结构</strong>：采用深层搅拌机就地将土和输入的水泥浆强行搅拌，形成连续搭接的水泥土柱状加固体挡墙。</li><li><strong>排桩与板墙式支护结构</strong>：开挖前在基坑周围设置砼灌注桩或钢板桩，桩的排列有间隔式、双排式和连续式，桩顶设置砼连系梁或锚桩、拉杆。</li><li><strong>土钉墙支护</strong>：在天然土体通过钻孔、插筋、注浆来设置土钉(亦称砂浆锚杆)并与喷射砼面板相结合，形成类似重力挡墙的土钉墙，以抵抗墙后的土压力，保持开挖面的稳定。</li><li><strong>土层锚杆支护结构</strong>：在深基础立壁上钻孔，并达到一定深度，然后在孔内放入钢筋等材料，灌入泥浆或化学浆液，使其与土层结合成为抗拉（拔）力强的锚杆，将立壁土体侧压力传至稳定土层。<blockquote><p>在实际工程中，其实上述某些方法可组合使用，例如挡土灌注桩（排桩）+土层锚杆等。</p></blockquote></li></ol><p>ial</p>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力学基础与专业基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
